"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Chromedriver = void 0;

require("source-map-support/register");

var _events = _interopRequireDefault(require("events"));

var _driver = require("appium/driver");

var _child_process = _interopRequireDefault(require("child_process"));

var _support = require("appium/support");

var _asyncbox = require("asyncbox");

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _utils = require("./utils");

var _semver = _interopRequireDefault(require("semver"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _compareVersions = _interopRequireDefault(require("compare-versions"));

var _storageClient = _interopRequireDefault(require("./storage-client"));

var _protocolHelpers = require("./protocol-helpers");

const NEW_CD_VERSION_FORMAT_MAJOR_VERSION = 73;
const DEFAULT_HOST = '127.0.0.1';
const MIN_CD_VERSION_WITH_W3C_SUPPORT = 75;
const DEFAULT_PORT = 9515;
const CHROME_BUNDLE_ID = 'com.android.chrome';
const WEBVIEW_SHELL_BUNDLE_ID = 'org.chromium.webview_shell';
const WEBVIEW_BUNDLE_IDS = ['com.google.android.webview', 'com.android.webview'];
const CHROMEDRIVER_TUTORIAL = 'https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/web/chromedriver.md';
const VERSION_PATTERN = /([\d.]+)/;
const CD_VERSION_TIMEOUT = 5000;

class Chromedriver extends _events.default.EventEmitter {
  constructor(args = {}) {
    super();
    const {
      host = DEFAULT_HOST,
      port = DEFAULT_PORT,
      useSystemExecutable = false,
      executable,
      executableDir = (0, _utils.getChromedriverDir)(),
      bundleId,
      mappingPath,
      cmdArgs,
      adb,
      verbose,
      logPath,
      disableBuildCheck,
      details,
      isAutodownloadEnabled = false
    } = args;
    this._log = _support.logger.getLogger((0, _utils.generateLogPrefix)(this));
    this.proxyHost = host;
    this.proxyPort = port;
    this.adb = adb;
    this.cmdArgs = cmdArgs;
    this.proc = null;
    this.useSystemExecutable = useSystemExecutable;
    this.chromedriver = executable;
    this.executableDir = executableDir;
    this.mappingPath = mappingPath;
    this.bundleId = bundleId;
    this.executableVerified = false;
    this.state = Chromedriver.STATE_STOPPED;
    this.jwproxy = new _driver.JWProxy({
      server: this.proxyHost,
      port: this.proxyPort,
      log: this._log
    });
    this.verbose = verbose;
    this.logPath = logPath;
    this.disableBuildCheck = !!disableBuildCheck;
    this.storageClient = isAutodownloadEnabled ? new _storageClient.default({
      chromedriverDir: this.executableDir
    }) : null;
    this.details = details;
    this.capabilities = {};
    this.desiredProtocol = _driver.PROTOCOLS.MJSONWP;
  }

  get log() {
    return this._log;
  }

  async getDriversMapping() {
    let mapping = _lodash.default.cloneDeep(_utils.CHROMEDRIVER_CHROME_MAPPING);

    if (this.mappingPath) {
      this.log.debug(`Attempting to use Chromedriver->Chrome mapping from '${this.mappingPath}'`);

      if (!(await _support.fs.exists(this.mappingPath))) {
        this.log.warn(`No file found at '${this.mappingPath}'`);
        this.log.info('Defaulting to the static Chromedriver->Chrome mapping');
      } else {
        try {
          mapping = JSON.parse(await _support.fs.readFile(this.mappingPath, 'utf8'));
        } catch (err) {
          this.log.warn(`Error parsing mapping from '${this.mappingPath}': ${err.message}`);
          this.log.info('Defaulting to the static Chromedriver->Chrome mapping');
        }
      }
    } else {
      this.log.debug('Using the static Chromedriver->Chrome mapping');
    }

    for (const [cdVersion, chromeVersion] of _lodash.default.toPairs(mapping)) {
      const coercedVersion = _semver.default.coerce(chromeVersion);

      if (coercedVersion) {
        mapping[cdVersion] = coercedVersion.version;
      } else {
        this.log.info(`'${chromeVersion}' is not a valid version number. Skipping it`);
      }
    }

    return mapping;
  }

  async getChromedrivers(mapping) {
    const executables = await _support.fs.glob('*', {
      cwd: this.executableDir,
      strict: false,
      nodir: true,
      absolute: true
    });
    this.log.debug(`Found ${_support.util.pluralize('executable', executables.length, true)} ` + `in '${this.executableDir}'`);
    const cds = (await (0, _asyncbox.asyncmap)(executables, async executable => {
      const logError = ({
        message,
        stdout = null,
        stderr = null
      }) => {
        let errMsg = `Cannot retrieve version number from '${_path.default.basename(executable)}' Chromedriver binary. ` + `Make sure it returns a valid version string in response to '--version' command line argument. ${message}`;

        if (stdout) {
          errMsg += `\nStdout: ${stdout}`;
        }

        if (stderr) {
          errMsg += `\nStderr: ${stderr}`;
        }

        this.log.warn(errMsg);
        return null;
      };

      let stdout;
      let stderr;

      try {
        ({
          stdout,
          stderr
        } = await (0, _teen_process.exec)(executable, ['--version'], {
          timeout: CD_VERSION_TIMEOUT
        }));
      } catch (err) {
        if (!(err.message || '').includes('timed out') && !(err.stdout || '').includes('Starting ChromeDriver')) {
          return logError(err);
        }

        stdout = err.stdout;
      }

      const match = /ChromeDriver\s+\(?v?([\d.]+)\)?/i.exec(stdout);

      if (!match) {
        return logError({
          message: 'Cannot parse the version string',
          stdout,
          stderr
        });
      }

      let version = match[1];
      let minChromeVersion = mapping[version];

      const coercedVersion = _semver.default.coerce(version);

      if (coercedVersion) {
        if (coercedVersion.major < NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          version = `${coercedVersion.major}.${coercedVersion.minor}`;
          minChromeVersion = mapping[version];
        }

        if (!minChromeVersion && coercedVersion.major >= NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          minChromeVersion = `${coercedVersion.major}`;
        }
      }

      return {
        executable,
        version,
        minChromeVersion
      };
    })).filter(cd => !!cd).sort((a, b) => (0, _compareVersions.default)(b.version, a.version));

    if (_lodash.default.isEmpty(cds)) {
      this.log.info(`No Chromedrivers were found in '${this.executableDir}'`);
      return cds;
    }

    this.log.debug(`The following Chromedriver executables were found:`);

    for (const cd of cds) {
      this.log.debug(`    '${cd.executable}' (version '${cd.version}', minimum Chrome version '${cd.minChromeVersion ? cd.minChromeVersion : 'Unknown'}')`);
    }

    return cds;
  }

  async getChromeVersion() {
    var _this$details, _this$details3, _this$details3$info;

    if ((_this$details = this.details) !== null && _this$details !== void 0 && _this$details.info) {
      var _this$details2, _this$details2$info;

      this.log.debug(`Browser version in the supplied details: ${(_this$details2 = this.details) === null || _this$details2 === void 0 ? void 0 : (_this$details2$info = _this$details2.info) === null || _this$details2$info === void 0 ? void 0 : _this$details2$info.Browser}`);
    }

    const versionMatch = VERSION_PATTERN.exec((_this$details3 = this.details) === null || _this$details3 === void 0 ? void 0 : (_this$details3$info = _this$details3.info) === null || _this$details3$info === void 0 ? void 0 : _this$details3$info.Browser);

    if (versionMatch) {
      const coercedVersion = _semver.default.coerce(versionMatch[1]);

      if (coercedVersion) {
        return coercedVersion;
      }
    }

    let chromeVersion;

    if (this.bundleId === WEBVIEW_SHELL_BUNDLE_ID) {
      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          return _semver.default.coerce(chromeVersion);
        }
      }

      return null;
    }

    if (this.adb) {
      const apiLevel = await this.adb.getApiLevel();

      if (apiLevel >= 24 && apiLevel <= 28 && [WEBVIEW_SHELL_BUNDLE_ID, ...WEBVIEW_BUNDLE_IDS].includes(this.bundleId)) {
        this.bundleId = CHROME_BUNDLE_ID;
      }
    }

    if (!this.bundleId) {
      this.bundleId = CHROME_BUNDLE_ID;

      for (const bundleId of WEBVIEW_BUNDLE_IDS) {
        chromeVersion = await (0, _utils.getChromeVersion)(this.adb, bundleId);

        if (chromeVersion) {
          this.bundleId = bundleId;
          break;
        }
      }
    }

    if (!chromeVersion) {
      chromeVersion = await (0, _utils.getChromeVersion)(this.adb, this.bundleId);
    }

    return chromeVersion ? _semver.default.coerce(chromeVersion) : null;
  }

  async updateDriversMapping(newMapping) {
    let shouldUpdateStaticMapping = true;

    if (await _support.fs.exists(this.mappingPath)) {
      try {
        await _support.fs.writeFile(this.mappingPath, JSON.stringify(newMapping, null, 2), 'utf8');
        shouldUpdateStaticMapping = false;
      } catch (e) {
        this.log.warn(`Cannot store the updated chromedrivers mapping into '${this.mappingPath}'. ` + `This may reduce the performance of further executions. Original error: ${e.message}`);
      }
    }

    if (shouldUpdateStaticMapping) {
      Object.assign(_utils.CHROMEDRIVER_CHROME_MAPPING, newMapping);
    }
  }

  async getCompatibleChromedriver() {
    if (!this.adb) {
      return await (0, _utils.getChromedriverBinaryPath)();
    }

    const mapping = await this.getDriversMapping();

    if (!_lodash.default.isEmpty(mapping)) {
      this.log.debug(`The most recent known Chrome version: ${_lodash.default.values(mapping)[0]}`);
    }

    let didStorageSync = false;

    const syncChromedrivers = async chromeVersion => {
      didStorageSync = true;
      const retrievedMapping = await this.storageClient.retrieveMapping();
      this.log.debug('Got chromedrivers mapping from the storage: ' + JSON.stringify(retrievedMapping, null, 2));
      const driverKeys = await this.storageClient.syncDrivers({
        minBrowserVersion: chromeVersion.major
      });

      if (_lodash.default.isEmpty(driverKeys)) {
        return false;
      }

      const synchronizedDriversMapping = driverKeys.reduce((acc, x) => {
        const {
          version,
          minBrowserVersion
        } = retrievedMapping[x];
        acc[version] = minBrowserVersion;
        return acc;
      }, {});
      Object.assign(mapping, synchronizedDriversMapping);
      await this.updateDriversMapping(mapping);
      return true;
    };

    do {
      const cds = await this.getChromedrivers(mapping);
      const missingVersions = {};

      for (const {
        version,
        minChromeVersion
      } of cds) {
        if (!minChromeVersion || mapping[version]) {
          continue;
        }

        const coercedVer = _semver.default.coerce(version);

        if (!coercedVer || coercedVer.major < NEW_CD_VERSION_FORMAT_MAJOR_VERSION) {
          continue;
        }

        missingVersions[version] = minChromeVersion;
      }

      if (!_lodash.default.isEmpty(missingVersions)) {
        this.log.info(`Found ${_support.util.pluralize('Chromedriver', _lodash.default.size(missingVersions), true)}, ` + `which ${_lodash.default.size(missingVersions) === 1 ? 'is' : 'are'} missing in the list of known versions: ` + JSON.stringify(missingVersions));
        await this.updateDriversMapping(Object.assign(mapping, missingVersions));
      }

      if (this.disableBuildCheck) {
        if (_lodash.default.isEmpty(cds)) {
          this.log.errorAndThrow(`There must be at least one Chromedriver executable available for use if ` + `'chromedriverDisableBuildCheck' capability is set to 'true'`);
        }

        const {
          version,
          executable
        } = cds[0];
        this.log.warn(`Chrome build check disabled. Using most recent Chromedriver version (${version}, at '${executable}')`);
        this.log.warn(`If this is wrong, set 'chromedriverDisableBuildCheck' capability to 'false'`);
        return executable;
      }

      const chromeVersion = await this.getChromeVersion();

      if (!chromeVersion) {
        if (_lodash.default.isEmpty(cds)) {
          this.log.errorAndThrow(`There must be at least one Chromedriver executable available for use if ` + `the current Chrome version cannot be determined`);
        }

        const {
          version,
          executable
        } = cds[0];
        this.log.warn(`Unable to discover Chrome version. Using Chromedriver ${version} at '${executable}'`);
        return executable;
      }

      this.log.debug(`Found Chrome bundle '${this.bundleId}' version '${chromeVersion}'`);
      const matchingDrivers = cds.filter(({
        minChromeVersion
      }) => {
        const minChromeVersionS = minChromeVersion && _semver.default.coerce(minChromeVersion);

        if (!minChromeVersionS) {
          return false;
        }

        return chromeVersion.major > NEW_CD_VERSION_FORMAT_MAJOR_VERSION ? minChromeVersionS.major === chromeVersion.major : _semver.default.gte(chromeVersion, minChromeVersionS);
      });

      if (_lodash.default.isEmpty(matchingDrivers)) {
        if (this.storageClient && !didStorageSync) {
          try {
            if (await syncChromedrivers(chromeVersion)) {
              continue;
            }
          } catch (e) {
            this.log.warn(`Cannot synchronize local chromedrivers with the remote storage at ${_utils.CD_CDN}: ` + e.message);
            this.log.debug(e.stack);
          }
        }

        const autodownloadSuggestion = 'You could also try to enable automated chromedrivers download server feature';
        throw new Error(`No Chromedriver found that can automate Chrome '${chromeVersion}'. ` + (!this.storageClient ? `${autodownloadSuggestion}. ` : '') + `See ${CHROMEDRIVER_TUTORIAL} for more details`);
      }

      const binPath = matchingDrivers[0].executable;
      this.log.debug(`Found ${_support.util.pluralize('executable', matchingDrivers.length, true)} ` + `capable of automating Chrome '${chromeVersion}'.\nChoosing the most recent, '${binPath}'.`);
      this.log.debug('If a specific version is required, specify it with the `chromedriverExecutable`' + 'desired capability.');
      return binPath;
    } while (true);
  }

  async initChromedriverPath() {
    if (this.executableVerified) return;

    if (!this.chromedriver) {
      this.chromedriver = this.useSystemExecutable ? await (0, _utils.getChromedriverBinaryPath)() : await this.getCompatibleChromedriver();
    }

    if (!(await _support.fs.exists(this.chromedriver))) {
      throw new Error(`Trying to use a chromedriver binary at the path ` + `${this.chromedriver}, but it doesn't exist!`);
    }

    this.executableVerified = true;
    this.log.info(`Set chromedriver binary as: ${this.chromedriver}`);
  }

  syncProtocol(cdVersion = null) {
    const coercedVersion = _semver.default.coerce(cdVersion);

    if (!coercedVersion || coercedVersion.major < MIN_CD_VERSION_WITH_W3C_SUPPORT) {
      this.log.debug(`Chromedriver v. ${cdVersion} does not fully support ${_driver.PROTOCOLS.W3C} protocol. ` + `Defaulting to ${_driver.PROTOCOLS.MJSONWP}`);
      return;
    }

    const chromeOptions = (0, _protocolHelpers.getCapValue)(this.capabilities, 'chromeOptions', {});

    if (chromeOptions.w3c === false) {
      this.log.info(`Chromedriver v. ${cdVersion} supports ${_driver.PROTOCOLS.W3C} protocol, ` + `but ${_driver.PROTOCOLS.MJSONWP} one has been explicitly requested`);
      return;
    }

    this.desiredProtocol = _driver.PROTOCOLS.W3C;
    this.capabilities = (0, _protocolHelpers.toW3cCapNames)(this.capabilities);
  }

  async start(caps, emitStartingState = true) {
    this.capabilities = _lodash.default.cloneDeep(caps);
    this.capabilities.loggingPrefs = _lodash.default.cloneDeep((0, _protocolHelpers.getCapValue)(caps, 'loggingPrefs', {}));

    if (_lodash.default.isEmpty(this.capabilities.loggingPrefs.browser)) {
      this.capabilities.loggingPrefs.browser = 'ALL';
    }

    if (emitStartingState) {
      this.changeState(Chromedriver.STATE_STARTING);
    }

    const args = [`--port=${this.proxyPort}`];

    if (this.adb && this.adb.adbPort) {
      args.push(`--adb-port=${this.adb.adbPort}`);
    }

    if (_lodash.default.isArray(this.cmdArgs)) {
      args.push(...this.cmdArgs);
    }

    if (this.logPath) {
      args.push(`--log-path=${this.logPath}`);
    }

    if (this.disableBuildCheck) {
      args.push('--disable-build-check');
    }

    args.push('--verbose');

    const startDetector = stdout => stdout.startsWith('Starting ');

    let processIsAlive = false;
    let webviewVersion;

    try {
      await this.initChromedriverPath();
      await this.killAll();
      this.proc = new _teen_process.SubProcess(this.chromedriver, args);
      processIsAlive = true;
      this.proc.on('output', (stdout, stderr) => {
        const out = stdout + stderr;
        let match = /"Browser": "(.*)"/.exec(out);

        if (match) {
          webviewVersion = match[1];
          this.log.debug(`Webview version: '${webviewVersion}'`);
        }

        match = /Starting ChromeDriver ([.\d]+)/.exec(out);

        if (match) {
          this.log.debug(`Chromedriver version: '${match[1]}'`);
          this.syncProtocol(match[1]);
        }

        if (this.verbose) {
          for (let line of (stdout || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            this.log.debug(`[STDOUT] ${line}`);
          }

          for (let line of (stderr || '').trim().split('\n')) {
            if (!line.trim().length) continue;
            this.log.error(`[STDERR] ${line}`);
          }
        }
      });
      this.proc.on('exit', (code, signal) => {
        processIsAlive = false;

        if (this.state !== Chromedriver.STATE_STOPPED && this.state !== Chromedriver.STATE_STOPPING && this.state !== Chromedriver.STATE_RESTARTING) {
          const msg = `Chromedriver exited unexpectedly with code ${code}, signal ${signal}`;
          this.log.error(msg);
          this.changeState(Chromedriver.STATE_STOPPED);
        }
      });
      this.log.info(`Spawning chromedriver with: ${this.chromedriver} ${args.join(' ')}`);
      await this.proc.start(startDetector);
      await this.waitForOnline();
      await this.startSession();
    } catch (e) {
      this.log.debug(e);
      this.emit(Chromedriver.EVENT_ERROR, e);

      if (processIsAlive) {
        await this.proc.stop();
      }

      let message = '';

      if (e.message.includes('Chrome version must be')) {
        var _exec;

        message += 'Unable to automate Chrome version because it is not supported by this version of Chromedriver.\n';

        if (webviewVersion) {
          message += `Chrome version on the device: ${webviewVersion}\n`;
        }

        const versionsSupportedByDriver = ((_exec = /Chrome version must be (.+)/.exec(e.message)) === null || _exec === void 0 ? void 0 : _exec[1]) || '';

        if (versionsSupportedByDriver) {
          message += `Chromedriver supports Chrome version(s): ${versionsSupportedByDriver}\n`;
        }

        message += `Visit '${CHROMEDRIVER_TUTORIAL}' to troubleshoot the problem.\n`;
      }

      message += e.message;
      this.log.errorAndThrow(message);
    }
  }

  sessionId() {
    return this.state === Chromedriver.STATE_ONLINE ? this.jwproxy.sessionId : null;
  }

  async restart() {
    this.log.info('Restarting chromedriver');

    if (this.state !== Chromedriver.STATE_ONLINE) {
      throw new Error("Can't restart when we're not online");
    }

    this.changeState(Chromedriver.STATE_RESTARTING);
    await this.stop(false);
    await this.start(this.capabilities, false);
  }

  async waitForOnline() {
    let chromedriverStopped = false;
    await (0, _asyncbox.retryInterval)(20, 200, async () => {
      if (this.state === Chromedriver.STATE_STOPPED) {
        chromedriverStopped = true;
        return;
      }

      await this.getStatus();
    });

    if (chromedriverStopped) {
      throw new Error('ChromeDriver crashed during startup.');
    }
  }

  async getStatus() {
    return await this.jwproxy.command('/status', 'GET');
  }

  async startSession() {
    const sessionCaps = this.desiredProtocol === _driver.PROTOCOLS.W3C ? {
      capabilities: {
        alwaysMatch: this.capabilities
      }
    } : {
      desiredCapabilities: this.capabilities
    };
    this.log.info(`Starting ${this.desiredProtocol} Chromedriver session with capabilities: ` + JSON.stringify(sessionCaps, null, 2));
    await this.jwproxy.command('/session', 'POST', sessionCaps);
    this.log.prefix = (0, _utils.generateLogPrefix)(this, this.jwproxy.sessionId);
    this.changeState(Chromedriver.STATE_ONLINE);
  }

  async stop(emitStates = true) {
    if (emitStates) {
      this.changeState(Chromedriver.STATE_STOPPING);
    }

    const runSafeStep = async f => {
      try {
        return await f();
      } catch (e) {
        this.log.warn(e.message);
        this.log.debug(e.stack);
      }
    };

    await runSafeStep(() => this.jwproxy.command('', 'DELETE'));
    await runSafeStep(() => this.proc.stop('SIGTERM', 20000));
    this.log.prefix = (0, _utils.generateLogPrefix)(this);

    if (emitStates) {
      this.changeState(Chromedriver.STATE_STOPPED);
    }
  }

  changeState(state) {
    this.state = state;
    this.log.debug(`Changed state to '${state}'`);
    this.emit(Chromedriver.EVENT_CHANGED, {
      state
    });
  }

  async sendCommand(url, method, body) {
    return await this.jwproxy.command(url, method, body);
  }

  async proxyReq(req, res) {
    return await this.jwproxy.proxyReqRes(req, res);
  }

  async killAll() {
    let cmd = _support.system.isWindows() ? `wmic process where "commandline like '%chromedriver.exe%--port=${this.proxyPort}%'" delete` : `pkill -15 -f "${this.chromedriver}.*--port=${this.proxyPort}"`;
    this.log.debug(`Killing any old chromedrivers, running: ${cmd}`);

    try {
      await _bluebird.default.promisify(_child_process.default.exec)(cmd);
      this.log.debug('Successfully cleaned up old chromedrivers');
    } catch (err) {
      this.log.warn('No old chromedrivers seem to exist');
    }

    if (this.adb) {
      const udidIndex = this.adb.executable.defaultArgs.findIndex(item => item === '-s');
      const udid = udidIndex > -1 ? this.adb.executable.defaultArgs[udidIndex + 1] : null;

      if (udid) {
        this.log.debug(`Cleaning this device's adb forwarded port socket connections: ${udid}`);
      } else {
        this.log.debug(`Cleaning any old adb forwarded port socket connections`);
      }

      try {
        for (let conn of await this.adb.getForwardList()) {
          if (!(conn.includes('webview_devtools') && (!udid || conn.includes(udid)))) {
            continue;
          }

          let params = conn.split(/\s+/);

          if (params.length > 1) {
            await this.adb.removePortForward(params[1].replace(/[\D]*/, ''));
          }
        }
      } catch (err) {
        this.log.warn(`Unable to clean forwarded ports. Error: '${err.message}'. Continuing.`);
      }
    }
  }

  async hasWorkingWebview() {
    try {
      await this.jwproxy.command('/url', 'GET');
      return true;
    } catch (e) {
      return false;
    }
  }

}

exports.Chromedriver = Chromedriver;
Chromedriver.EVENT_ERROR = 'chromedriver_error';
Chromedriver.EVENT_CHANGED = 'stateChanged';
Chromedriver.STATE_STOPPED = 'stopped';
Chromedriver.STATE_STARTING = 'starting';
Chromedriver.STATE_ONLINE = 'online';
Chromedriver.STATE_STOPPING = 'stopping';
Chromedriver.STATE_RESTARTING = 'restarting';
var _default = Chromedriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliL2Nocm9tZWRyaXZlci5qcyIsIm5hbWVzIjpbIk5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OIiwiREVGQVVMVF9IT1NUIiwiTUlOX0NEX1ZFUlNJT05fV0lUSF9XM0NfU1VQUE9SVCIsIkRFRkFVTFRfUE9SVCIsIkNIUk9NRV9CVU5ETEVfSUQiLCJXRUJWSUVXX1NIRUxMX0JVTkRMRV9JRCIsIldFQlZJRVdfQlVORExFX0lEUyIsIkNIUk9NRURSSVZFUl9UVVRPUklBTCIsIlZFUlNJT05fUEFUVEVSTiIsIkNEX1ZFUlNJT05fVElNRU9VVCIsIkNocm9tZWRyaXZlciIsImV2ZW50cyIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiYXJncyIsImhvc3QiLCJwb3J0IiwidXNlU3lzdGVtRXhlY3V0YWJsZSIsImV4ZWN1dGFibGUiLCJleGVjdXRhYmxlRGlyIiwiZ2V0Q2hyb21lZHJpdmVyRGlyIiwiYnVuZGxlSWQiLCJtYXBwaW5nUGF0aCIsImNtZEFyZ3MiLCJhZGIiLCJ2ZXJib3NlIiwibG9nUGF0aCIsImRpc2FibGVCdWlsZENoZWNrIiwiZGV0YWlscyIsImlzQXV0b2Rvd25sb2FkRW5hYmxlZCIsIl9sb2ciLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJnZW5lcmF0ZUxvZ1ByZWZpeCIsInByb3h5SG9zdCIsInByb3h5UG9ydCIsInByb2MiLCJjaHJvbWVkcml2ZXIiLCJleGVjdXRhYmxlVmVyaWZpZWQiLCJzdGF0ZSIsIlNUQVRFX1NUT1BQRUQiLCJqd3Byb3h5IiwiSldQcm94eSIsInNlcnZlciIsImxvZyIsInN0b3JhZ2VDbGllbnQiLCJDaHJvbWVkcml2ZXJTdG9yYWdlQ2xpZW50IiwiY2hyb21lZHJpdmVyRGlyIiwiY2FwYWJpbGl0aWVzIiwiZGVzaXJlZFByb3RvY29sIiwiUFJPVE9DT0xTIiwiTUpTT05XUCIsImdldERyaXZlcnNNYXBwaW5nIiwibWFwcGluZyIsIl8iLCJjbG9uZURlZXAiLCJDSFJPTUVEUklWRVJfQ0hST01FX01BUFBJTkciLCJkZWJ1ZyIsImZzIiwiZXhpc3RzIiwid2FybiIsImluZm8iLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZSIsImVyciIsIm1lc3NhZ2UiLCJjZFZlcnNpb24iLCJjaHJvbWVWZXJzaW9uIiwidG9QYWlycyIsImNvZXJjZWRWZXJzaW9uIiwic2VtdmVyIiwiY29lcmNlIiwidmVyc2lvbiIsImdldENocm9tZWRyaXZlcnMiLCJleGVjdXRhYmxlcyIsImdsb2IiLCJjd2QiLCJzdHJpY3QiLCJub2RpciIsImFic29sdXRlIiwidXRpbCIsInBsdXJhbGl6ZSIsImxlbmd0aCIsImNkcyIsImFzeW5jbWFwIiwibG9nRXJyb3IiLCJzdGRvdXQiLCJzdGRlcnIiLCJlcnJNc2ciLCJwYXRoIiwiYmFzZW5hbWUiLCJleGVjIiwidGltZW91dCIsImluY2x1ZGVzIiwibWF0Y2giLCJtaW5DaHJvbWVWZXJzaW9uIiwibWFqb3IiLCJtaW5vciIsImZpbHRlciIsImNkIiwic29ydCIsImEiLCJiIiwiY29tcGFyZVZlcnNpb25zIiwiaXNFbXB0eSIsImdldENocm9tZVZlcnNpb24iLCJCcm93c2VyIiwidmVyc2lvbk1hdGNoIiwiYXBpTGV2ZWwiLCJnZXRBcGlMZXZlbCIsInVwZGF0ZURyaXZlcnNNYXBwaW5nIiwibmV3TWFwcGluZyIsInNob3VsZFVwZGF0ZVN0YXRpY01hcHBpbmciLCJ3cml0ZUZpbGUiLCJzdHJpbmdpZnkiLCJlIiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0Q29tcGF0aWJsZUNocm9tZWRyaXZlciIsImdldENocm9tZWRyaXZlckJpbmFyeVBhdGgiLCJ2YWx1ZXMiLCJkaWRTdG9yYWdlU3luYyIsInN5bmNDaHJvbWVkcml2ZXJzIiwicmV0cmlldmVkTWFwcGluZyIsInJldHJpZXZlTWFwcGluZyIsImRyaXZlcktleXMiLCJzeW5jRHJpdmVycyIsIm1pbkJyb3dzZXJWZXJzaW9uIiwic3luY2hyb25pemVkRHJpdmVyc01hcHBpbmciLCJyZWR1Y2UiLCJhY2MiLCJ4IiwibWlzc2luZ1ZlcnNpb25zIiwiY29lcmNlZFZlciIsInNpemUiLCJlcnJvckFuZFRocm93IiwibWF0Y2hpbmdEcml2ZXJzIiwibWluQ2hyb21lVmVyc2lvblMiLCJndGUiLCJDRF9DRE4iLCJzdGFjayIsImF1dG9kb3dubG9hZFN1Z2dlc3Rpb24iLCJFcnJvciIsImJpblBhdGgiLCJpbml0Q2hyb21lZHJpdmVyUGF0aCIsInN5bmNQcm90b2NvbCIsIlczQyIsImNocm9tZU9wdGlvbnMiLCJnZXRDYXBWYWx1ZSIsInczYyIsInRvVzNjQ2FwTmFtZXMiLCJzdGFydCIsImNhcHMiLCJlbWl0U3RhcnRpbmdTdGF0ZSIsImxvZ2dpbmdQcmVmcyIsImJyb3dzZXIiLCJjaGFuZ2VTdGF0ZSIsIlNUQVRFX1NUQVJUSU5HIiwiYWRiUG9ydCIsInB1c2giLCJpc0FycmF5Iiwic3RhcnREZXRlY3RvciIsInN0YXJ0c1dpdGgiLCJwcm9jZXNzSXNBbGl2ZSIsIndlYnZpZXdWZXJzaW9uIiwia2lsbEFsbCIsIlN1YlByb2Nlc3MiLCJvbiIsIm91dCIsImxpbmUiLCJ0cmltIiwic3BsaXQiLCJlcnJvciIsImNvZGUiLCJzaWduYWwiLCJTVEFURV9TVE9QUElORyIsIlNUQVRFX1JFU1RBUlRJTkciLCJtc2ciLCJqb2luIiwid2FpdEZvck9ubGluZSIsInN0YXJ0U2Vzc2lvbiIsImVtaXQiLCJFVkVOVF9FUlJPUiIsInN0b3AiLCJ2ZXJzaW9uc1N1cHBvcnRlZEJ5RHJpdmVyIiwic2Vzc2lvbklkIiwiU1RBVEVfT05MSU5FIiwicmVzdGFydCIsImNocm9tZWRyaXZlclN0b3BwZWQiLCJyZXRyeUludGVydmFsIiwiZ2V0U3RhdHVzIiwiY29tbWFuZCIsInNlc3Npb25DYXBzIiwiYWx3YXlzTWF0Y2giLCJkZXNpcmVkQ2FwYWJpbGl0aWVzIiwicHJlZml4IiwiZW1pdFN0YXRlcyIsInJ1blNhZmVTdGVwIiwiZiIsIkVWRU5UX0NIQU5HRUQiLCJzZW5kQ29tbWFuZCIsInVybCIsIm1ldGhvZCIsImJvZHkiLCJwcm94eVJlcSIsInJlcSIsInJlcyIsInByb3h5UmVxUmVzIiwiY21kIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiQiIsInByb21pc2lmeSIsImNwIiwidWRpZEluZGV4IiwiZGVmYXVsdEFyZ3MiLCJmaW5kSW5kZXgiLCJpdGVtIiwidWRpZCIsImNvbm4iLCJnZXRGb3J3YXJkTGlzdCIsInBhcmFtcyIsInJlbW92ZVBvcnRGb3J3YXJkIiwicmVwbGFjZSIsImhhc1dvcmtpbmdXZWJ2aWV3Il0sInNvdXJjZVJvb3QiOiIuLi8uLiIsInNvdXJjZXMiOlsibGliL2Nocm9tZWRyaXZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bWFpblxuXG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBKV1Byb3h5LCBQUk9UT0NPTFMgfSBmcm9tICdhcHBpdW0vZHJpdmVyJztcbmltcG9ydCBjcCBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIGxvZ2dlciwgdXRpbCB9IGZyb20gJ2FwcGl1bS9zdXBwb3J0JztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwsIGFzeW5jbWFwIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IHsgU3ViUHJvY2VzcywgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQge1xuICBnZXRDaHJvbWVWZXJzaW9uLCBnZXRDaHJvbWVkcml2ZXJEaXIsIENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORyxcbiAgZ2V0Q2hyb21lZHJpdmVyQmluYXJ5UGF0aCwgQ0RfQ0ROLCBnZW5lcmF0ZUxvZ1ByZWZpeFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBjb21wYXJlVmVyc2lvbnMgZnJvbSAnY29tcGFyZS12ZXJzaW9ucyc7XG5pbXBvcnQgQ2hyb21lZHJpdmVyU3RvcmFnZUNsaWVudCBmcm9tICcuL3N0b3JhZ2UtY2xpZW50JztcbmltcG9ydCB7IHRvVzNjQ2FwTmFtZXMsIGdldENhcFZhbHVlIH0gZnJvbSAnLi9wcm90b2NvbC1oZWxwZXJzJztcblxuY29uc3QgTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04gPSA3MztcbmNvbnN0IERFRkFVTFRfSE9TVCA9ICcxMjcuMC4wLjEnO1xuY29uc3QgTUlOX0NEX1ZFUlNJT05fV0lUSF9XM0NfU1VQUE9SVCA9IDc1O1xuY29uc3QgREVGQVVMVF9QT1JUID0gOTUxNTtcbmNvbnN0IENIUk9NRV9CVU5ETEVfSUQgPSAnY29tLmFuZHJvaWQuY2hyb21lJztcbmNvbnN0IFdFQlZJRVdfU0hFTExfQlVORExFX0lEID0gJ29yZy5jaHJvbWl1bS53ZWJ2aWV3X3NoZWxsJztcbmNvbnN0IFdFQlZJRVdfQlVORExFX0lEUyA9IFtcbiAgJ2NvbS5nb29nbGUuYW5kcm9pZC53ZWJ2aWV3JyxcbiAgJ2NvbS5hbmRyb2lkLndlYnZpZXcnLFxuXTtcbmNvbnN0IENIUk9NRURSSVZFUl9UVVRPUklBTCA9ICdodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9ibG9iL21hc3Rlci9kb2NzL2VuL3dyaXRpbmctcnVubmluZy1hcHBpdW0vd2ViL2Nocm9tZWRyaXZlci5tZCc7XG5jb25zdCBWRVJTSU9OX1BBVFRFUk4gPSAvKFtcXGQuXSspLztcblxuY29uc3QgQ0RfVkVSU0lPTl9USU1FT1VUID0gNTAwMDtcblxuY2xhc3MgQ2hyb21lZHJpdmVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChhcmdzID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3Qge1xuICAgICAgaG9zdCA9IERFRkFVTFRfSE9TVCxcbiAgICAgIHBvcnQgPSBERUZBVUxUX1BPUlQsXG4gICAgICB1c2VTeXN0ZW1FeGVjdXRhYmxlID0gZmFsc2UsXG4gICAgICBleGVjdXRhYmxlLFxuICAgICAgZXhlY3V0YWJsZURpciA9IGdldENocm9tZWRyaXZlckRpcigpLFxuICAgICAgYnVuZGxlSWQsXG4gICAgICBtYXBwaW5nUGF0aCxcbiAgICAgIGNtZEFyZ3MsXG4gICAgICBhZGIsXG4gICAgICB2ZXJib3NlLFxuICAgICAgbG9nUGF0aCxcbiAgICAgIGRpc2FibGVCdWlsZENoZWNrLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGlzQXV0b2Rvd25sb2FkRW5hYmxlZCA9IGZhbHNlLFxuICAgIH0gPSBhcmdzO1xuICAgIHRoaXMuX2xvZyA9IGxvZ2dlci5nZXRMb2dnZXIoZ2VuZXJhdGVMb2dQcmVmaXgodGhpcykpO1xuXG4gICAgdGhpcy5wcm94eUhvc3QgPSBob3N0O1xuICAgIHRoaXMucHJveHlQb3J0ID0gcG9ydDtcbiAgICB0aGlzLmFkYiA9IGFkYjtcbiAgICB0aGlzLmNtZEFyZ3MgPSBjbWRBcmdzO1xuICAgIHRoaXMucHJvYyA9IG51bGw7XG4gICAgdGhpcy51c2VTeXN0ZW1FeGVjdXRhYmxlID0gdXNlU3lzdGVtRXhlY3V0YWJsZTtcbiAgICB0aGlzLmNocm9tZWRyaXZlciA9IGV4ZWN1dGFibGU7XG4gICAgdGhpcy5leGVjdXRhYmxlRGlyID0gZXhlY3V0YWJsZURpcjtcbiAgICB0aGlzLm1hcHBpbmdQYXRoID0gbWFwcGluZ1BhdGg7XG4gICAgdGhpcy5idW5kbGVJZCA9IGJ1bmRsZUlkO1xuICAgIHRoaXMuZXhlY3V0YWJsZVZlcmlmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IENocm9tZWRyaXZlci5TVEFURV9TVE9QUEVEO1xuICAgIHRoaXMuandwcm94eSA9IG5ldyBKV1Byb3h5KHtcbiAgICAgIHNlcnZlcjogdGhpcy5wcm94eUhvc3QsXG4gICAgICBwb3J0OiB0aGlzLnByb3h5UG9ydCxcbiAgICAgIGxvZzogdGhpcy5fbG9nLFxuICAgIH0pO1xuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gICAgdGhpcy5sb2dQYXRoID0gbG9nUGF0aDtcbiAgICB0aGlzLmRpc2FibGVCdWlsZENoZWNrID0gISFkaXNhYmxlQnVpbGRDaGVjaztcbiAgICB0aGlzLnN0b3JhZ2VDbGllbnQgPSBpc0F1dG9kb3dubG9hZEVuYWJsZWRcbiAgICAgID8gbmV3IENocm9tZWRyaXZlclN0b3JhZ2VDbGllbnQoeyBjaHJvbWVkcml2ZXJEaXI6IHRoaXMuZXhlY3V0YWJsZURpciB9KVxuICAgICAgOiBudWxsO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgdGhpcy5jYXBhYmlsaXRpZXMgPSB7fTtcbiAgICB0aGlzLmRlc2lyZWRQcm90b2NvbCA9IFBST1RPQ09MUy5NSlNPTldQO1xuICB9XG5cbiAgZ2V0IGxvZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvZztcbiAgfVxuXG4gIGFzeW5jIGdldERyaXZlcnNNYXBwaW5nICgpIHtcbiAgICBsZXQgbWFwcGluZyA9IF8uY2xvbmVEZWVwKENIUk9NRURSSVZFUl9DSFJPTUVfTUFQUElORyk7XG4gICAgaWYgKHRoaXMubWFwcGluZ1BhdGgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBBdHRlbXB0aW5nIHRvIHVzZSBDaHJvbWVkcml2ZXItPkNocm9tZSBtYXBwaW5nIGZyb20gJyR7dGhpcy5tYXBwaW5nUGF0aH0nYCk7XG4gICAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLm1hcHBpbmdQYXRoKSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKGBObyBmaWxlIGZvdW5kIGF0ICcke3RoaXMubWFwcGluZ1BhdGh9J2ApO1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdEZWZhdWx0aW5nIHRvIHRoZSBzdGF0aWMgQ2hyb21lZHJpdmVyLT5DaHJvbWUgbWFwcGluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYXBwaW5nID0gSlNPTi5wYXJzZShhd2FpdCBmcy5yZWFkRmlsZSh0aGlzLm1hcHBpbmdQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihgRXJyb3IgcGFyc2luZyBtYXBwaW5nIGZyb20gJyR7dGhpcy5tYXBwaW5nUGF0aH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oJ0RlZmF1bHRpbmcgdG8gdGhlIHN0YXRpYyBDaHJvbWVkcml2ZXItPkNocm9tZSBtYXBwaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ1VzaW5nIHRoZSBzdGF0aWMgQ2hyb21lZHJpdmVyLT5DaHJvbWUgbWFwcGluZycpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZXMgZm9yIG1pbmltdW0gY2hyb21lIHZlcnNpb24gYXJlIHNlbXZlciBjb21wbGlhbnRcbiAgICBmb3IgKGNvbnN0IFtjZFZlcnNpb24sIGNocm9tZVZlcnNpb25dIG9mIF8udG9QYWlycyhtYXBwaW5nKSkge1xuICAgICAgY29uc3QgY29lcmNlZFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNocm9tZVZlcnNpb24pO1xuICAgICAgaWYgKGNvZXJjZWRWZXJzaW9uKSB7XG4gICAgICAgIG1hcHBpbmdbY2RWZXJzaW9uXSA9IGNvZXJjZWRWZXJzaW9uLnZlcnNpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKGAnJHtjaHJvbWVWZXJzaW9ufScgaXMgbm90IGEgdmFsaWQgdmVyc2lvbiBudW1iZXIuIFNraXBwaW5nIGl0YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q2hyb21lZHJpdmVycyAobWFwcGluZykge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIHZlcnNpb25zIGF2YWlsYWJsZVxuICAgIGNvbnN0IGV4ZWN1dGFibGVzID0gYXdhaXQgZnMuZ2xvYignKicsIHtcbiAgICAgIGN3ZDogdGhpcy5leGVjdXRhYmxlRGlyLFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgIG5vZGlyOiB0cnVlLFxuICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgfSk7XG4gICAgdGhpcy5sb2cuZGVidWcoYEZvdW5kICR7dXRpbC5wbHVyYWxpemUoJ2V4ZWN1dGFibGUnLCBleGVjdXRhYmxlcy5sZW5ndGgsIHRydWUpfSBgICtcbiAgICAgIGBpbiAnJHt0aGlzLmV4ZWN1dGFibGVEaXJ9J2ApO1xuICAgIGNvbnN0IGNkcyA9IChhd2FpdCBhc3luY21hcChleGVjdXRhYmxlcywgYXN5bmMgKGV4ZWN1dGFibGUpID0+IHtcbiAgICAgIGNvbnN0IGxvZ0Vycm9yID0gKHttZXNzYWdlLCBzdGRvdXQgPSBudWxsLCBzdGRlcnIgPSBudWxsfSkgPT4ge1xuICAgICAgICBsZXQgZXJyTXNnID0gYENhbm5vdCByZXRyaWV2ZSB2ZXJzaW9uIG51bWJlciBmcm9tICcke3BhdGguYmFzZW5hbWUoZXhlY3V0YWJsZSl9JyBDaHJvbWVkcml2ZXIgYmluYXJ5LiBgICtcbiAgICAgICAgICBgTWFrZSBzdXJlIGl0IHJldHVybnMgYSB2YWxpZCB2ZXJzaW9uIHN0cmluZyBpbiByZXNwb25zZSB0byAnLS12ZXJzaW9uJyBjb21tYW5kIGxpbmUgYXJndW1lbnQuICR7bWVzc2FnZX1gO1xuICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgZXJyTXNnICs9IGBcXG5TdGRvdXQ6ICR7c3Rkb3V0fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICAgIGVyck1zZyArPSBgXFxuU3RkZXJyOiAke3N0ZGVycn1gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLndhcm4oZXJyTXNnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICBsZXQgc3Rkb3V0O1xuICAgICAgbGV0IHN0ZGVycjtcbiAgICAgIHRyeSB7XG4gICAgICAgICh7c3Rkb3V0LCBzdGRlcnJ9ID0gYXdhaXQgZXhlYyhleGVjdXRhYmxlLCBbJy0tdmVyc2lvbiddLCB7XG4gICAgICAgICAgdGltZW91dDogQ0RfVkVSU0lPTl9USU1FT1VULFxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyLm1lc3NhZ2UgfHwgJycpLmluY2x1ZGVzKCd0aW1lZCBvdXQnKSAmJiAhKGVyci5zdGRvdXQgfHwgJycpLmluY2x1ZGVzKCdTdGFydGluZyBDaHJvbWVEcml2ZXInKSkge1xuICAgICAgICAgIHJldHVybiBsb2dFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBoYXMgdGltZWQgb3V0LCBpdCBoYXMgYWN0dWFsbHkgc3RhcnRlZCBDaHJvbWVkcml2ZXIsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlcmUgd2lsbCBhbHNvIGJlIHRoZSB2ZXJzaW9uIHN0cmluZyBpbiB0aGUgb3V0cHV0XG4gICAgICAgIHN0ZG91dCA9IGVyci5zdGRvdXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gL0Nocm9tZURyaXZlclxccytcXCg/dj8oW1xcZC5dKylcXCk/L2kuZXhlYyhzdGRvdXQpOyAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL3pwajV3QS8xXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcih7bWVzc2FnZTogJ0Nhbm5vdCBwYXJzZSB0aGUgdmVyc2lvbiBzdHJpbmcnLCBzdGRvdXQsIHN0ZGVycn0pO1xuICAgICAgfVxuICAgICAgbGV0IHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgICAgIGxldCBtaW5DaHJvbWVWZXJzaW9uID0gbWFwcGluZ1t2ZXJzaW9uXTtcbiAgICAgIGNvbnN0IGNvZXJjZWRWZXJzaW9uID0gc2VtdmVyLmNvZXJjZSh2ZXJzaW9uKTtcbiAgICAgIGlmIChjb2VyY2VkVmVyc2lvbikge1xuICAgICAgICAvLyBiZWZvcmUgMjAxOS0wMy0wNiB2ZXJzaW9ucyB3ZXJlIG9mIHRoZSBmb3JtIG1ham9yLm1pbm9yXG4gICAgICAgIGlmIChjb2VyY2VkVmVyc2lvbi5tYWpvciA8IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IGAke2NvZXJjZWRWZXJzaW9uLm1ham9yfS4ke2NvZXJjZWRWZXJzaW9uLm1pbm9yfWA7XG4gICAgICAgICAgbWluQ2hyb21lVmVyc2lvbiA9IG1hcHBpbmdbdmVyc2lvbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtaW5DaHJvbWVWZXJzaW9uICYmIGNvZXJjZWRWZXJzaW9uLm1ham9yID49IE5FV19DRF9WRVJTSU9OX0ZPUk1BVF9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgLy8gQXNzdW1lIHRoZSBtYWpvciBDaHJvbWUgdmVyc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBkcml2ZXIgbWFqb3IgdmVyc2lvblxuICAgICAgICAgIG1pbkNocm9tZVZlcnNpb24gPSBgJHtjb2VyY2VkVmVyc2lvbi5tYWpvcn1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBtaW5DaHJvbWVWZXJzaW9uLFxuICAgICAgfTtcbiAgICB9KSlcbiAgICAgIC5maWx0ZXIoKGNkKSA9PiAhIWNkKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGNvbXBhcmVWZXJzaW9ucyhiLnZlcnNpb24sIGEudmVyc2lvbikpO1xuICAgIGlmIChfLmlzRW1wdHkoY2RzKSkge1xuICAgICAgdGhpcy5sb2cuaW5mbyhgTm8gQ2hyb21lZHJpdmVycyB3ZXJlIGZvdW5kIGluICcke3RoaXMuZXhlY3V0YWJsZURpcn0nYCk7XG4gICAgICByZXR1cm4gY2RzO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgVGhlIGZvbGxvd2luZyBDaHJvbWVkcml2ZXIgZXhlY3V0YWJsZXMgd2VyZSBmb3VuZDpgKTtcbiAgICBmb3IgKGNvbnN0IGNkIG9mIGNkcykge1xuICAgICAgdGhpcy5sb2cuZGVidWcoYCAgICAnJHtjZC5leGVjdXRhYmxlfScgKHZlcnNpb24gJyR7Y2QudmVyc2lvbn0nLCBtaW5pbXVtIENocm9tZSB2ZXJzaW9uICcke2NkLm1pbkNocm9tZVZlcnNpb24gPyBjZC5taW5DaHJvbWVWZXJzaW9uIDogJ1Vua25vd24nfScpYCk7XG4gICAgfVxuICAgIHJldHVybiBjZHM7XG4gIH1cblxuICBhc3luYyBnZXRDaHJvbWVWZXJzaW9uICgpIHtcbiAgICAvLyBUcnkgdG8gcmV0cmlldmUgdGhlIHZlcnNpb24gZnJvbSBgZGV0YWlsc2AgcHJvcGVydHkgaWYgaXQgaXMgc2V0XG4gICAgLy8gVGhlIGBpbmZvYCBpdGVtIG11c3QgY29udGFpbiB0aGUgb3V0cHV0IG9mIC9qc29uL3ZlcnNpb24gQ0RQIGNvbW1hbmRcbiAgICAvLyB3aGVyZSBgQnJvd3NlcmAgZmllbGQgbG9va3MgbGlrZSBgQ2hyb21lLzcyLjAuMzYwMS4wYGBcbiAgICBpZiAodGhpcy5kZXRhaWxzPy5pbmZvKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhgQnJvd3NlciB2ZXJzaW9uIGluIHRoZSBzdXBwbGllZCBkZXRhaWxzOiAke3RoaXMuZGV0YWlscz8uaW5mbz8uQnJvd3Nlcn1gKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbk1hdGNoID0gVkVSU0lPTl9QQVRURVJOLmV4ZWModGhpcy5kZXRhaWxzPy5pbmZvPy5Ccm93c2VyKTtcbiAgICBpZiAodmVyc2lvbk1hdGNoKSB7XG4gICAgICBjb25zdCBjb2VyY2VkVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UodmVyc2lvbk1hdGNoWzFdKTtcbiAgICAgIGlmIChjb2VyY2VkVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gY29lcmNlZFZlcnNpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGNocm9tZVZlcnNpb247XG5cbiAgICAvLyBpbiBjYXNlIG9mIFdlYlZpZXcgQnJvd3NlciBUZXN0ZXIsIHNpbXBseSB0cnkgdG8gZmluZCB0aGUgdW5kZXJseWluZyB3ZWJ2aWV3XG4gICAgaWYgKHRoaXMuYnVuZGxlSWQgPT09IFdFQlZJRVdfU0hFTExfQlVORExFX0lEKSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1bmRsZUlkIG9mIFdFQlZJRVdfQlVORExFX0lEUykge1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gYXdhaXQgZ2V0Q2hyb21lVmVyc2lvbih0aGlzLmFkYiwgYnVuZGxlSWQpO1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICAgICAgICByZXR1cm4gc2VtdmVyLmNvZXJjZShjaHJvbWVWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gb24gQW5kcm9pZCA3LTkgd2Vidmlld3MgYXJlIGJhY2tlZCBieSB0aGUgbWFpbiBDaHJvbWUsIG5vdCB0aGUgc3lzdGVtIHdlYnZpZXdcbiAgICBpZiAodGhpcy5hZGIpIHtcbiAgICAgIGNvbnN0IGFwaUxldmVsID0gYXdhaXQgdGhpcy5hZGIuZ2V0QXBpTGV2ZWwoKTtcbiAgICAgIGlmIChhcGlMZXZlbCA+PSAyNCAmJiBhcGlMZXZlbCA8PSAyOCAmJlxuICAgICAgICAgIFtXRUJWSUVXX1NIRUxMX0JVTkRMRV9JRCwgLi4uV0VCVklFV19CVU5ETEVfSURTXS5pbmNsdWRlcyh0aGlzLmJ1bmRsZUlkKSkge1xuICAgICAgICB0aGlzLmJ1bmRsZUlkID0gQ0hST01FX0JVTkRMRV9JRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cnkgb3V0IHdlYnZpZXdzIHdoZW4gbm8gYnVuZGxlIGlkIGlzIHNlbnQgaW5cbiAgICBpZiAoIXRoaXMuYnVuZGxlSWQpIHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gdGhlIGdlbmVyaWMgQ2hyb21lIGJ1bmRsZVxuICAgICAgdGhpcy5idW5kbGVJZCA9IENIUk9NRV9CVU5ETEVfSUQ7XG5cbiAgICAgIC8vIHdlIGhhdmUgYSB3ZWJ2aWV3IG9mIHNvbWUgc29ydCwgc28gdHJ5IHRvIGZpbmQgdGhlIGJ1bmRsZSB2ZXJzaW9uXG4gICAgICBmb3IgKGNvbnN0IGJ1bmRsZUlkIG9mIFdFQlZJRVdfQlVORExFX0lEUykge1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gYXdhaXQgZ2V0Q2hyb21lVmVyc2lvbih0aGlzLmFkYiwgYnVuZGxlSWQpO1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGRvIG5vdCBoYXZlIGEgY2hyb21lIHZlcnNpb24sIGl0IG11c3Qgbm90IGJlIGEgd2Vidmlld1xuICAgIGlmICghY2hyb21lVmVyc2lvbikge1xuICAgICAgY2hyb21lVmVyc2lvbiA9IGF3YWl0IGdldENocm9tZVZlcnNpb24odGhpcy5hZGIsIHRoaXMuYnVuZGxlSWQpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSBpdCBpcyBzZW12ZXIsIHNvIGxhdGVyIGNoZWNrcyB3b24ndCBmYWlsXG4gICAgcmV0dXJuIGNocm9tZVZlcnNpb24gPyBzZW12ZXIuY29lcmNlKGNocm9tZVZlcnNpb24pIDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZURyaXZlcnNNYXBwaW5nIChuZXdNYXBwaW5nKSB7XG4gICAgbGV0IHNob3VsZFVwZGF0ZVN0YXRpY01hcHBpbmcgPSB0cnVlO1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHModGhpcy5tYXBwaW5nUGF0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0aGlzLm1hcHBpbmdQYXRoLCBKU09OLnN0cmluZ2lmeShuZXdNYXBwaW5nLCBudWxsLCAyKSwgJ3V0ZjgnKTtcbiAgICAgICAgc2hvdWxkVXBkYXRlU3RhdGljTWFwcGluZyA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKGBDYW5ub3Qgc3RvcmUgdGhlIHVwZGF0ZWQgY2hyb21lZHJpdmVycyBtYXBwaW5nIGludG8gJyR7dGhpcy5tYXBwaW5nUGF0aH0nLiBgICtcbiAgICAgICAgICBgVGhpcyBtYXkgcmVkdWNlIHRoZSBwZXJmb3JtYW5jZSBvZiBmdXJ0aGVyIGV4ZWN1dGlvbnMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFVwZGF0ZVN0YXRpY01hcHBpbmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oQ0hST01FRFJJVkVSX0NIUk9NRV9NQVBQSU5HLCBuZXdNYXBwaW5nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRDb21wYXRpYmxlQ2hyb21lZHJpdmVyICgpIHtcbiAgICBpZiAoIXRoaXMuYWRiKSB7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0Q2hyb21lZHJpdmVyQmluYXJ5UGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcHBpbmcgPSBhd2FpdCB0aGlzLmdldERyaXZlcnNNYXBwaW5nKCk7XG4gICAgaWYgKCFfLmlzRW1wdHkobWFwcGluZykpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBUaGUgbW9zdCByZWNlbnQga25vd24gQ2hyb21lIHZlcnNpb246ICR7Xy52YWx1ZXMobWFwcGluZylbMF19YCk7XG4gICAgfVxuXG4gICAgbGV0IGRpZFN0b3JhZ2VTeW5jID0gZmFsc2U7XG4gICAgY29uc3Qgc3luY0Nocm9tZWRyaXZlcnMgPSBhc3luYyAoY2hyb21lVmVyc2lvbikgPT4ge1xuICAgICAgZGlkU3RvcmFnZVN5bmMgPSB0cnVlO1xuICAgICAgY29uc3QgcmV0cmlldmVkTWFwcGluZyA9IGF3YWl0IHRoaXMuc3RvcmFnZUNsaWVudC5yZXRyaWV2ZU1hcHBpbmcoKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdHb3QgY2hyb21lZHJpdmVycyBtYXBwaW5nIGZyb20gdGhlIHN0b3JhZ2U6ICcgK1xuICAgICAgICBKU09OLnN0cmluZ2lmeShyZXRyaWV2ZWRNYXBwaW5nLCBudWxsLCAyKSk7XG4gICAgICBjb25zdCBkcml2ZXJLZXlzID0gYXdhaXQgdGhpcy5zdG9yYWdlQ2xpZW50LnN5bmNEcml2ZXJzKHtcbiAgICAgICAgbWluQnJvd3NlclZlcnNpb246IGNocm9tZVZlcnNpb24ubWFqb3IsXG4gICAgICB9KTtcbiAgICAgIGlmIChfLmlzRW1wdHkoZHJpdmVyS2V5cykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3luY2hyb25pemVkRHJpdmVyc01hcHBpbmcgPSBkcml2ZXJLZXlzLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICAgIGNvbnN0IHt2ZXJzaW9uLCBtaW5Ccm93c2VyVmVyc2lvbn0gPSByZXRyaWV2ZWRNYXBwaW5nW3hdO1xuICAgICAgICBhY2NbdmVyc2lvbl0gPSBtaW5Ccm93c2VyVmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24obWFwcGluZywgc3luY2hyb25pemVkRHJpdmVyc01hcHBpbmcpO1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVEcml2ZXJzTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBjZHMgPSBhd2FpdCB0aGlzLmdldENocm9tZWRyaXZlcnMobWFwcGluZyk7XG5cbiAgICAgIGNvbnN0IG1pc3NpbmdWZXJzaW9ucyA9IHt9O1xuICAgICAgZm9yIChjb25zdCB7dmVyc2lvbiwgbWluQ2hyb21lVmVyc2lvbn0gb2YgY2RzKSB7XG4gICAgICAgIGlmICghbWluQ2hyb21lVmVyc2lvbiB8fCBtYXBwaW5nW3ZlcnNpb25dKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29lcmNlZFZlciA9IHNlbXZlci5jb2VyY2UodmVyc2lvbik7XG4gICAgICAgIGlmICghY29lcmNlZFZlciB8fCBjb2VyY2VkVmVyLm1ham9yIDwgTkVXX0NEX1ZFUlNJT05fRk9STUFUX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pc3NpbmdWZXJzaW9uc1t2ZXJzaW9uXSA9IG1pbkNocm9tZVZlcnNpb247XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNFbXB0eShtaXNzaW5nVmVyc2lvbnMpKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oYEZvdW5kICR7dXRpbC5wbHVyYWxpemUoJ0Nocm9tZWRyaXZlcicsIF8uc2l6ZShtaXNzaW5nVmVyc2lvbnMpLCB0cnVlKX0sIGAgK1xuICAgICAgICAgIGB3aGljaCAke18uc2l6ZShtaXNzaW5nVmVyc2lvbnMpID09PSAxID8gJ2lzJyA6ICdhcmUnfSBtaXNzaW5nIGluIHRoZSBsaXN0IG9mIGtub3duIHZlcnNpb25zOiBgICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShtaXNzaW5nVmVyc2lvbnMpKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVEcml2ZXJzTWFwcGluZyhPYmplY3QuYXNzaWduKG1hcHBpbmcsIG1pc3NpbmdWZXJzaW9ucykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlQnVpbGRDaGVjaykge1xuICAgICAgICBpZiAoXy5pc0VtcHR5KGNkcykpIHtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvckFuZFRocm93KGBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBDaHJvbWVkcml2ZXIgZXhlY3V0YWJsZSBhdmFpbGFibGUgZm9yIHVzZSBpZiBgICtcbiAgICAgICAgICAgIGAnY2hyb21lZHJpdmVyRGlzYWJsZUJ1aWxkQ2hlY2snIGNhcGFiaWxpdHkgaXMgc2V0IHRvICd0cnVlJ2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHt2ZXJzaW9uLCBleGVjdXRhYmxlfSA9IGNkc1swXTtcbiAgICAgICAgdGhpcy5sb2cud2FybihgQ2hyb21lIGJ1aWxkIGNoZWNrIGRpc2FibGVkLiBVc2luZyBtb3N0IHJlY2VudCBDaHJvbWVkcml2ZXIgdmVyc2lvbiAoJHt2ZXJzaW9ufSwgYXQgJyR7ZXhlY3V0YWJsZX0nKWApO1xuICAgICAgICB0aGlzLmxvZy53YXJuKGBJZiB0aGlzIGlzIHdyb25nLCBzZXQgJ2Nocm9tZWRyaXZlckRpc2FibGVCdWlsZENoZWNrJyBjYXBhYmlsaXR5IHRvICdmYWxzZSdgKTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNocm9tZVZlcnNpb24gPSBhd2FpdCB0aGlzLmdldENocm9tZVZlcnNpb24oKTtcbiAgICAgIGlmICghY2hyb21lVmVyc2lvbikge1xuICAgICAgICAvLyB1bmFibGUgdG8gZ2V0IHRoZSBjaHJvbWUgdmVyc2lvblxuICAgICAgICBpZiAoXy5pc0VtcHR5KGNkcykpIHtcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvckFuZFRocm93KGBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBDaHJvbWVkcml2ZXIgZXhlY3V0YWJsZSBhdmFpbGFibGUgZm9yIHVzZSBpZiBgICtcbiAgICAgICAgICAgIGB0aGUgY3VycmVudCBDaHJvbWUgdmVyc2lvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHt2ZXJzaW9uLCBleGVjdXRhYmxlfSA9IGNkc1swXTtcbiAgICAgICAgdGhpcy5sb2cud2FybihgVW5hYmxlIHRvIGRpc2NvdmVyIENocm9tZSB2ZXJzaW9uLiBVc2luZyBDaHJvbWVkcml2ZXIgJHt2ZXJzaW9ufSBhdCAnJHtleGVjdXRhYmxlfSdgKTtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGFibGU7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhgRm91bmQgQ2hyb21lIGJ1bmRsZSAnJHt0aGlzLmJ1bmRsZUlkfScgdmVyc2lvbiAnJHtjaHJvbWVWZXJzaW9ufSdgKTtcblxuICAgICAgY29uc3QgbWF0Y2hpbmdEcml2ZXJzID0gY2RzLmZpbHRlcigoe21pbkNocm9tZVZlcnNpb259KSA9PiB7XG4gICAgICAgIGNvbnN0IG1pbkNocm9tZVZlcnNpb25TID0gbWluQ2hyb21lVmVyc2lvbiAmJiBzZW12ZXIuY29lcmNlKG1pbkNocm9tZVZlcnNpb24pO1xuICAgICAgICBpZiAoIW1pbkNocm9tZVZlcnNpb25TKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNocm9tZVZlcnNpb24ubWFqb3IgPiBORVdfQ0RfVkVSU0lPTl9GT1JNQVRfTUFKT1JfVkVSU0lPTlxuICAgICAgICAgID8gbWluQ2hyb21lVmVyc2lvblMubWFqb3IgPT09IGNocm9tZVZlcnNpb24ubWFqb3JcbiAgICAgICAgICA6IHNlbXZlci5ndGUoY2hyb21lVmVyc2lvbiwgbWluQ2hyb21lVmVyc2lvblMpO1xuICAgICAgfSk7XG4gICAgICBpZiAoXy5pc0VtcHR5KG1hdGNoaW5nRHJpdmVycykpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZUNsaWVudCAmJiAhZGlkU3RvcmFnZVN5bmMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHN5bmNDaHJvbWVkcml2ZXJzKGNocm9tZVZlcnNpb24pKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oYENhbm5vdCBzeW5jaHJvbml6ZSBsb2NhbCBjaHJvbWVkcml2ZXJzIHdpdGggdGhlIHJlbW90ZSBzdG9yYWdlIGF0ICR7Q0RfQ0ROfTogYCArXG4gICAgICAgICAgICAgIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhlLnN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0b2Rvd25sb2FkU3VnZ2VzdGlvbiA9XG4gICAgICAgICAgJ1lvdSBjb3VsZCBhbHNvIHRyeSB0byBlbmFibGUgYXV0b21hdGVkIGNocm9tZWRyaXZlcnMgZG93bmxvYWQgc2VydmVyIGZlYXR1cmUnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIENocm9tZWRyaXZlciBmb3VuZCB0aGF0IGNhbiBhdXRvbWF0ZSBDaHJvbWUgJyR7Y2hyb21lVmVyc2lvbn0nLiBgICtcbiAgICAgICAgICAoIXRoaXMuc3RvcmFnZUNsaWVudCA/IGAke2F1dG9kb3dubG9hZFN1Z2dlc3Rpb259LiBgIDogJycpICtcbiAgICAgICAgICBgU2VlICR7Q0hST01FRFJJVkVSX1RVVE9SSUFMfSBmb3IgbW9yZSBkZXRhaWxzYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJpblBhdGggPSBtYXRjaGluZ0RyaXZlcnNbMF0uZXhlY3V0YWJsZTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBGb3VuZCAke3V0aWwucGx1cmFsaXplKCdleGVjdXRhYmxlJywgbWF0Y2hpbmdEcml2ZXJzLmxlbmd0aCwgdHJ1ZSl9IGAgK1xuICAgICAgICBgY2FwYWJsZSBvZiBhdXRvbWF0aW5nIENocm9tZSAnJHtjaHJvbWVWZXJzaW9ufScuXFxuQ2hvb3NpbmcgdGhlIG1vc3QgcmVjZW50LCAnJHtiaW5QYXRofScuYCk7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnSWYgYSBzcGVjaWZpYyB2ZXJzaW9uIGlzIHJlcXVpcmVkLCBzcGVjaWZ5IGl0IHdpdGggdGhlIGBjaHJvbWVkcml2ZXJFeGVjdXRhYmxlYCcgK1xuICAgICAgICAnZGVzaXJlZCBjYXBhYmlsaXR5LicpO1xuICAgICAgcmV0dXJuIGJpblBhdGg7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgYXN5bmMgaW5pdENocm9tZWRyaXZlclBhdGggKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGFibGVWZXJpZmllZCkgcmV0dXJuOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcblxuICAgIC8vIHRoZSBleGVjdXRhYmxlIG1pZ2h0IGJlIHNldCAoaWYgcGFzc2VkIGluKVxuICAgIC8vIG9yIHdlIG1pZ2h0IHdhbnQgdG8gdXNlIHRoZSBiYXNpYyBvbmUgaW5zdGFsbGVkIHdpdGggdGhpcyBkcml2ZXJcbiAgICAvLyBvciB3ZSB3YW50IHRvIGZpZ3VyZSBvdXQgdGhlIGJlc3Qgb25lXG4gICAgaWYgKCF0aGlzLmNocm9tZWRyaXZlcikge1xuICAgICAgdGhpcy5jaHJvbWVkcml2ZXIgPSB0aGlzLnVzZVN5c3RlbUV4ZWN1dGFibGVcbiAgICAgICAgPyBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKClcbiAgICAgICAgOiBhd2FpdCB0aGlzLmdldENvbXBhdGlibGVDaHJvbWVkcml2ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyh0aGlzLmNocm9tZWRyaXZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIHVzZSBhIGNocm9tZWRyaXZlciBiaW5hcnkgYXQgdGhlIHBhdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jaHJvbWVkcml2ZXJ9LCBidXQgaXQgZG9lc24ndCBleGlzdCFgKTtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRhYmxlVmVyaWZpZWQgPSB0cnVlO1xuICAgIHRoaXMubG9nLmluZm8oYFNldCBjaHJvbWVkcml2ZXIgYmluYXJ5IGFzOiAke3RoaXMuY2hyb21lZHJpdmVyfWApO1xuICB9XG5cbiAgc3luY1Byb3RvY29sIChjZFZlcnNpb24gPSBudWxsKSB7XG4gICAgY29uc3QgY29lcmNlZFZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNkVmVyc2lvbik7XG4gICAgaWYgKCFjb2VyY2VkVmVyc2lvbiB8fCBjb2VyY2VkVmVyc2lvbi5tYWpvciA8IE1JTl9DRF9WRVJTSU9OX1dJVEhfVzNDX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBDaHJvbWVkcml2ZXIgdi4gJHtjZFZlcnNpb259IGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgJHtQUk9UT0NPTFMuVzNDfSBwcm90b2NvbC4gYCArXG4gICAgICAgIGBEZWZhdWx0aW5nIHRvICR7UFJPVE9DT0xTLk1KU09OV1B9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNocm9tZU9wdGlvbnMgPSBnZXRDYXBWYWx1ZSh0aGlzLmNhcGFiaWxpdGllcywgJ2Nocm9tZU9wdGlvbnMnLCB7fSk7XG4gICAgaWYgKGNocm9tZU9wdGlvbnMudzNjID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2cuaW5mbyhgQ2hyb21lZHJpdmVyIHYuICR7Y2RWZXJzaW9ufSBzdXBwb3J0cyAke1BST1RPQ09MUy5XM0N9IHByb3RvY29sLCBgICtcbiAgICAgICAgYGJ1dCAke1BST1RPQ09MUy5NSlNPTldQfSBvbmUgaGFzIGJlZW4gZXhwbGljaXRseSByZXF1ZXN0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXNpcmVkUHJvdG9jb2wgPSBQUk9UT0NPTFMuVzNDO1xuICAgIC8vIGdpdmVuIGNhcHMgbWlnaHQgbm90IGJlIHByb3Blcmx5IHByZWZpeGVkXG4gICAgLy8gc28gd2UgdHJ5IHRvIGZpeCB0aGVtIGluIG9yZGVyIHRvIHByb3Blcmx5IGluaXRcbiAgICAvLyB0aGUgbmV3IFczQyBzZXNzaW9uXG4gICAgdGhpcy5jYXBhYmlsaXRpZXMgPSB0b1czY0NhcE5hbWVzKHRoaXMuY2FwYWJpbGl0aWVzKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0IChjYXBzLCBlbWl0U3RhcnRpbmdTdGF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLmNhcGFiaWxpdGllcyA9IF8uY2xvbmVEZWVwKGNhcHMpO1xuXG4gICAgLy8gc2V0IHRoZSBsb2dnaW5nIHByZWZlcmVuY2VzIHRvIEFMTCB0aGUgY29uc29sZSBsb2dzXG4gICAgdGhpcy5jYXBhYmlsaXRpZXMubG9nZ2luZ1ByZWZzID0gXy5jbG9uZURlZXAoZ2V0Q2FwVmFsdWUoY2FwcywgJ2xvZ2dpbmdQcmVmcycsIHt9KSk7XG4gICAgaWYgKF8uaXNFbXB0eSh0aGlzLmNhcGFiaWxpdGllcy5sb2dnaW5nUHJlZnMuYnJvd3NlcikpIHtcbiAgICAgIHRoaXMuY2FwYWJpbGl0aWVzLmxvZ2dpbmdQcmVmcy5icm93c2VyID0gJ0FMTCc7XG4gICAgfVxuXG4gICAgaWYgKGVtaXRTdGFydGluZ1N0YXRlKSB7XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKENocm9tZWRyaXZlci5TVEFURV9TVEFSVElORyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtgLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9YF07XG4gICAgaWYgKHRoaXMuYWRiICYmIHRoaXMuYWRiLmFkYlBvcnQpIHtcbiAgICAgIGFyZ3MucHVzaChgLS1hZGItcG9ydD0ke3RoaXMuYWRiLmFkYlBvcnR9YCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkodGhpcy5jbWRBcmdzKSkge1xuICAgICAgYXJncy5wdXNoKC4uLnRoaXMuY21kQXJncyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxvZ1BhdGgpIHtcbiAgICAgIGFyZ3MucHVzaChgLS1sb2ctcGF0aD0ke3RoaXMubG9nUGF0aH1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZUJ1aWxkQ2hlY2spIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1kaXNhYmxlLWJ1aWxkLWNoZWNrJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnLS12ZXJib3NlJyk7XG4gICAgLy8gd2hhdCBhcmUgdGhlIHByb2Nlc3Mgc3Rkb3V0L3N0ZGVyciBjb25kaXRpb25zIHdoZXJlaW4gd2Uga25vdyB0aGF0XG4gICAgLy8gdGhlIHByb2Nlc3MgaGFzIHN0YXJ0ZWQgdG8gb3VyIHNhdGlzZmFjdGlvbj9cbiAgICBjb25zdCBzdGFydERldGVjdG9yID0gKHN0ZG91dCkgPT4gc3Rkb3V0LnN0YXJ0c1dpdGgoJ1N0YXJ0aW5nICcpO1xuXG4gICAgbGV0IHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgbGV0IHdlYnZpZXdWZXJzaW9uO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRDaHJvbWVkcml2ZXJQYXRoKCk7XG4gICAgICBhd2FpdCB0aGlzLmtpbGxBbGwoKTtcblxuICAgICAgLy8gc2V0IHVwIG91ciBzdWJwcm9jZXNzIG9iamVjdFxuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3ModGhpcy5jaHJvbWVkcml2ZXIsIGFyZ3MpO1xuICAgICAgcHJvY2Vzc0lzQWxpdmUgPSB0cnVlO1xuXG4gICAgICAvLyBoYW5kbGUgbG9nIG91dHB1dFxuICAgICAgdGhpcy5wcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgLy8gaWYgdGhlIGNkIG91dHB1dCBpcyBub3QgcHJpbnRlZCwgZmluZCB0aGUgY2hyb21lIHZlcnNpb24gYW5kIHByaW50XG4gICAgICAgIC8vIHdpbGwgZ2V0IGEgcmVzcG9uc2UgbGlrZVxuICAgICAgICAvLyAgIERldlRvb2xzIHJlc3BvbnNlOiB7XG4gICAgICAgIC8vICAgICAgXCJBbmRyb2lkLVBhY2thZ2VcIjogXCJpby5hcHBpdW0uc2FtcGxlYXBwXCIsXG4gICAgICAgIC8vICAgICAgXCJCcm93c2VyXCI6IFwiQ2hyb21lLzU1LjAuMjg4My45MVwiLFxuICAgICAgICAvLyAgICAgIFwiUHJvdG9jb2wtVmVyc2lvblwiOiBcIjEuMlwiLFxuICAgICAgICAvLyAgICAgIFwiVXNlci1BZ2VudFwiOiBcIi4uLlwiLFxuICAgICAgICAvLyAgICAgIFwiV2ViS2l0LVZlcnNpb25cIjogXCI1MzcuMzZcIlxuICAgICAgICAvLyAgIH1cbiAgICAgICAgY29uc3Qgb3V0ID0gc3Rkb3V0ICsgc3RkZXJyO1xuICAgICAgICBsZXQgbWF0Y2ggPSAvXCJCcm93c2VyXCI6IFwiKC4qKVwiLy5leGVjKG91dCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHdlYnZpZXdWZXJzaW9uID0gbWF0Y2hbMV07XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYFdlYnZpZXcgdmVyc2lvbjogJyR7d2Vidmlld1ZlcnNpb259J2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxzbyBwcmludCBjaHJvbWVkcml2ZXIgdmVyc2lvbiB0byBsb2dzXG4gICAgICAgIC8vIHdpbGwgb3V0cHV0IHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vICBTdGFydGluZyBDaHJvbWVEcml2ZXIgMi4zMy41MDYxMDYgKDhhMDZjMzljNDU4MmZiZmJhYjY5NjZkYmIxYzM4YTkxNzNiZmIxYTIpIG9uIHBvcnQgOTUxNVxuICAgICAgICBtYXRjaCA9IC9TdGFydGluZyBDaHJvbWVEcml2ZXIgKFsuXFxkXSspLy5leGVjKG91dCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBDaHJvbWVkcml2ZXIgdmVyc2lvbjogJyR7bWF0Y2hbMV19J2ApO1xuICAgICAgICAgIHRoaXMuc3luY1Byb3RvY29sKG1hdGNoWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdpdmUgdGhlIG91dHB1dCBpZiBpdCBpcyByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCAnJykudHJpbSgpLnNwbGl0KCdcXG4nKSkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLnRyaW0oKS5sZW5ndGgpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgW1NURE9VVF0gJHtsaW5lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIChzdGRlcnIgfHwgJycpLnRyaW0oKS5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgICAgIGlmICghbGluZS50cmltKCkubGVuZ3RoKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoYFtTVERFUlJdICR7bGluZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUgb3V0LW9mLWJvdW5kIGV4aXQgYnkgc2ltcGx5IGVtaXR0aW5nIGEgc3RvcHBlZCBzdGF0ZVxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICBwcm9jZXNzSXNBbGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IENocm9tZWRyaXZlci5TVEFURV9TVE9QUElORyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gQ2hyb21lZHJpdmVyLlNUQVRFX1JFU1RBUlRJTkcpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgQ2hyb21lZHJpdmVyIGV4aXRlZCB1bmV4cGVjdGVkbHkgd2l0aCBjb2RlICR7Y29kZX0sIHNpZ25hbCAke3NpZ25hbH1gO1xuICAgICAgICAgIHRoaXMubG9nLmVycm9yKG1zZyk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2cuaW5mbyhgU3Bhd25pbmcgY2hyb21lZHJpdmVyIHdpdGg6ICR7dGhpcy5jaHJvbWVkcml2ZXJ9ICR7YXJncy5qb2luKCcgJyl9YCk7XG4gICAgICAvLyBzdGFydCBzdWJwcm9jIGFuZCB3YWl0IGZvciBzdGFydERldGVjdG9yXG4gICAgICBhd2FpdCB0aGlzLnByb2Muc3RhcnQoc3RhcnREZXRlY3Rvcik7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JPbmxpbmUoKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnRTZXNzaW9uKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoZSk7XG4gICAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SLCBlKTtcbiAgICAgIC8vIGp1c3QgYmVjYXVzZSB3ZSBoYWQgYW4gZXJyb3IgZG9lc24ndCBtZWFuIHRoZSBjaHJvbWVkcml2ZXIgcHJvY2Vzc1xuICAgICAgLy8gZmluaXNoZWQ7IHdlIHNob3VsZCBjbGVhbiB1cCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChwcm9jZXNzSXNBbGl2ZSkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgLy8gb2Z0ZW4gdGhlIHVzZXIncyBDaHJvbWUgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSB2ZXJzaW9uIG9mIENocm9tZWRyaXZlclxuICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcygnQ2hyb21lIHZlcnNpb24gbXVzdCBiZScpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gJ1VuYWJsZSB0byBhdXRvbWF0ZSBDaHJvbWUgdmVyc2lvbiBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIENocm9tZWRyaXZlci5cXG4nO1xuICAgICAgICBpZiAod2Vidmlld1ZlcnNpb24pIHtcbiAgICAgICAgICBtZXNzYWdlICs9IGBDaHJvbWUgdmVyc2lvbiBvbiB0aGUgZGV2aWNlOiAke3dlYnZpZXdWZXJzaW9ufVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbnNTdXBwb3J0ZWRCeURyaXZlciA9IC9DaHJvbWUgdmVyc2lvbiBtdXN0IGJlICguKykvLmV4ZWMoZS5tZXNzYWdlKT8uWzFdIHx8ICcnO1xuICAgICAgICBpZiAodmVyc2lvbnNTdXBwb3J0ZWRCeURyaXZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gYENocm9tZWRyaXZlciBzdXBwb3J0cyBDaHJvbWUgdmVyc2lvbihzKTogJHt2ZXJzaW9uc1N1cHBvcnRlZEJ5RHJpdmVyfVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSArPSBgVmlzaXQgJyR7Q0hST01FRFJJVkVSX1RVVE9SSUFMfScgdG8gdHJvdWJsZXNob290IHRoZSBwcm9ibGVtLlxcbmA7XG4gICAgICB9XG5cbiAgICAgIG1lc3NhZ2UgKz0gZS5tZXNzYWdlO1xuICAgICAgdGhpcy5sb2cuZXJyb3JBbmRUaHJvdyhtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBzZXNzaW9uSWQgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FID8gdGhpcy5qd3Byb3h5LnNlc3Npb25JZCA6IG51bGw7XG4gIH1cblxuICBhc3luYyByZXN0YXJ0ICgpIHtcbiAgICB0aGlzLmxvZy5pbmZvKCdSZXN0YXJ0aW5nIGNocm9tZWRyaXZlcicpO1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZXN0YXJ0IHdoZW4gd2UncmUgbm90IG9ubGluZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfUkVTVEFSVElORyk7XG4gICAgYXdhaXQgdGhpcy5zdG9wKGZhbHNlKTtcbiAgICBhd2FpdCB0aGlzLnN0YXJ0KHRoaXMuY2FwYWJpbGl0aWVzLCBmYWxzZSk7XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yT25saW5lICgpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IENEIGhhc24ndCBjcmFzaGVkXG4gICAgbGV0IGNocm9tZWRyaXZlclN0b3BwZWQgPSBmYWxzZTtcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDIwLCAyMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCkge1xuICAgICAgICAvLyB3ZSBhcmUgZWl0aGVyIHN0b3BwZWQgb3Igc3RvcHBpbmcsIHNvIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgIGNocm9tZWRyaXZlclN0b3BwZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmdldFN0YXR1cygpO1xuICAgIH0pO1xuICAgIGlmIChjaHJvbWVkcml2ZXJTdG9wcGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nocm9tZURyaXZlciBjcmFzaGVkIGR1cmluZyBzdGFydHVwLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvc3RhdHVzJywgJ0dFVCcpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRTZXNzaW9uICgpIHtcbiAgICBjb25zdCBzZXNzaW9uQ2FwcyA9IHRoaXMuZGVzaXJlZFByb3RvY29sID09PSBQUk9UT0NPTFMuVzNDXG4gICAgICA/IHtjYXBhYmlsaXRpZXM6IHthbHdheXNNYXRjaDogdGhpcy5jYXBhYmlsaXRpZXN9fVxuICAgICAgOiB7ZGVzaXJlZENhcGFiaWxpdGllczogdGhpcy5jYXBhYmlsaXRpZXN9O1xuICAgIHRoaXMubG9nLmluZm8oYFN0YXJ0aW5nICR7dGhpcy5kZXNpcmVkUHJvdG9jb2x9IENocm9tZWRyaXZlciBzZXNzaW9uIHdpdGggY2FwYWJpbGl0aWVzOiBgICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHNlc3Npb25DYXBzLCBudWxsLCAyKSk7XG4gICAgYXdhaXQgdGhpcy5qd3Byb3h5LmNvbW1hbmQoJy9zZXNzaW9uJywgJ1BPU1QnLCBzZXNzaW9uQ2Fwcyk7XG4gICAgdGhpcy5sb2cucHJlZml4ID0gZ2VuZXJhdGVMb2dQcmVmaXgodGhpcywgdGhpcy5qd3Byb3h5LnNlc3Npb25JZCk7XG4gICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfT05MSU5FKTtcbiAgfVxuXG4gIGFzeW5jIHN0b3AgKGVtaXRTdGF0ZXMgPSB0cnVlKSB7XG4gICAgaWYgKGVtaXRTdGF0ZXMpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HKTtcbiAgICB9XG4gICAgY29uc3QgcnVuU2FmZVN0ZXAgPSBhc3luYyAoZikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJ1blNhZmVTdGVwKCgpID0+IHRoaXMuandwcm94eS5jb21tYW5kKCcnLCAnREVMRVRFJykpO1xuICAgIGF3YWl0IHJ1blNhZmVTdGVwKCgpID0+IHRoaXMucHJvYy5zdG9wKCdTSUdURVJNJywgMjAwMDApKTtcbiAgICB0aGlzLmxvZy5wcmVmaXggPSBnZW5lcmF0ZUxvZ1ByZWZpeCh0aGlzKTtcbiAgICBpZiAoZW1pdFN0YXRlcykge1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShDaHJvbWVkcml2ZXIuU1RBVEVfU1RPUFBFRCk7XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUgKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubG9nLmRlYnVnKGBDaGFuZ2VkIHN0YXRlIHRvICcke3N0YXRlfSdgKTtcbiAgICB0aGlzLmVtaXQoQ2hyb21lZHJpdmVyLkVWRU5UX0NIQU5HRUQsIHtzdGF0ZX0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZENvbW1hbmQgKHVybCwgbWV0aG9kLCBib2R5KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKHVybCwgbWV0aG9kLCBib2R5KTtcbiAgfVxuXG4gIGFzeW5jIHByb3h5UmVxIChyZXEsIHJlcykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkucHJveHlSZXFSZXMocmVxLCByZXMpO1xuICB9XG5cbiAgYXN5bmMga2lsbEFsbCAoKSB7XG4gICAgbGV0IGNtZCA9IHN5c3RlbS5pc1dpbmRvd3MoKVxuICAgICAgPyBgd21pYyBwcm9jZXNzIHdoZXJlIFwiY29tbWFuZGxpbmUgbGlrZSAnJWNocm9tZWRyaXZlci5leGUlLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9JSdcIiBkZWxldGVgXG4gICAgICA6IGBwa2lsbCAtMTUgLWYgXCIke3RoaXMuY2hyb21lZHJpdmVyfS4qLS1wb3J0PSR7dGhpcy5wcm94eVBvcnR9XCJgO1xuICAgIHRoaXMubG9nLmRlYnVnKGBLaWxsaW5nIGFueSBvbGQgY2hyb21lZHJpdmVycywgcnVubmluZzogJHtjbWR9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IChCLnByb21pc2lmeShjcC5leGVjKSkoY21kKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgY2hyb21lZHJpdmVycycpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5sb2cud2FybignTm8gb2xkIGNocm9tZWRyaXZlcnMgc2VlbSB0byBleGlzdCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFkYikge1xuICAgICAgY29uc3QgdWRpZEluZGV4ID0gdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09ICctcycpO1xuICAgICAgY29uc3QgdWRpZCA9IHVkaWRJbmRleCA+IC0xID8gdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJnc1t1ZGlkSW5kZXggKyAxXSA6IG51bGw7XG5cbiAgICAgIGlmICh1ZGlkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBDbGVhbmluZyB0aGlzIGRldmljZSdzIGFkYiBmb3J3YXJkZWQgcG9ydCBzb2NrZXQgY29ubmVjdGlvbnM6ICR7dWRpZH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBDbGVhbmluZyBhbnkgb2xkIGFkYiBmb3J3YXJkZWQgcG9ydCBzb2NrZXQgY29ubmVjdGlvbnNgKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChsZXQgY29ubiBvZiBhd2FpdCB0aGlzLmFkYi5nZXRGb3J3YXJkTGlzdCgpKSB7XG4gICAgICAgICAgLy8gY2hyb21lZHJpdmVyIHdpbGwgYXNrIEFEQiB0byBmb3J3YXJkIGEgcG9ydCBsaWtlIFwiZGV2aWNlSWQgdGNwOnBvcnQgbG9jYWxhYnN0cmFjdDp3ZWJ2aWV3X2RldnRvb2xzX3JlbW90ZV9wb3J0XCJcbiAgICAgICAgICBpZiAoIShjb25uLmluY2x1ZGVzKCd3ZWJ2aWV3X2RldnRvb2xzJykgJiYgKCF1ZGlkIHx8IGNvbm4uaW5jbHVkZXModWRpZCkpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHBhcmFtcyA9IGNvbm4uc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRiLnJlbW92ZVBvcnRGb3J3YXJkKHBhcmFtc1sxXS5yZXBsYWNlKC9bXFxEXSovLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oYFVuYWJsZSB0byBjbGVhbiBmb3J3YXJkZWQgcG9ydHMuIEVycm9yOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhc1dvcmtpbmdXZWJ2aWV3ICgpIHtcbiAgICAvLyBzb21ldGltZXMgY2hyb21lZHJpdmVyIHN0b3BzIGF1dG9tYXRpbmcgd2Vidmlld3MuIHRoaXMgbWV0aG9kIHJ1bnMgYVxuICAgIC8vIHNpbXBsZSBjb21tYW5kIHRvIGRldGVybWluZSBvdXIgc3RhdGUsIGFuZCByZXNwb25kcyBhY2NvcmRpbmdseVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3VybCcsICdHRVQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuQ2hyb21lZHJpdmVyLkVWRU5UX0VSUk9SID0gJ2Nocm9tZWRyaXZlcl9lcnJvcic7XG5DaHJvbWVkcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5DaHJvbWVkcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuQ2hyb21lZHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcbkNocm9tZWRyaXZlci5TVEFURV9SRVNUQVJUSU5HID0gJ3Jlc3RhcnRpbmcnO1xuXG5leHBvcnQgeyBDaHJvbWVkcml2ZXIgfTtcbmV4cG9ydCBkZWZhdWx0IENocm9tZWRyaXZlcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxtQ0FBbUMsR0FBRyxFQUE1QztBQUNBLE1BQU1DLFlBQVksR0FBRyxXQUFyQjtBQUNBLE1BQU1DLCtCQUErQixHQUFHLEVBQXhDO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLElBQXJCO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsb0JBQXpCO0FBQ0EsTUFBTUMsdUJBQXVCLEdBQUcsNEJBQWhDO0FBQ0EsTUFBTUMsa0JBQWtCLEdBQUcsQ0FDekIsNEJBRHlCLEVBRXpCLHFCQUZ5QixDQUEzQjtBQUlBLE1BQU1DLHFCQUFxQixHQUFHLGlHQUE5QjtBQUNBLE1BQU1DLGVBQWUsR0FBRyxVQUF4QjtBQUVBLE1BQU1DLGtCQUFrQixHQUFHLElBQTNCOztBQUVBLE1BQU1DLFlBQU4sU0FBMkJDLGVBQUEsQ0FBT0MsWUFBbEMsQ0FBK0M7RUFDN0NDLFdBQVcsQ0FBRUMsSUFBSSxHQUFHLEVBQVQsRUFBYTtJQUN0QjtJQUVBLE1BQU07TUFDSkMsSUFBSSxHQUFHZCxZQURIO01BRUplLElBQUksR0FBR2IsWUFGSDtNQUdKYyxtQkFBbUIsR0FBRyxLQUhsQjtNQUlKQyxVQUpJO01BS0pDLGFBQWEsR0FBRyxJQUFBQyx5QkFBQSxHQUxaO01BTUpDLFFBTkk7TUFPSkMsV0FQSTtNQVFKQyxPQVJJO01BU0pDLEdBVEk7TUFVSkMsT0FWSTtNQVdKQyxPQVhJO01BWUpDLGlCQVpJO01BYUpDLE9BYkk7TUFjSkMscUJBQXFCLEdBQUc7SUFkcEIsSUFlRmYsSUFmSjtJQWdCQSxLQUFLZ0IsSUFBTCxHQUFZQyxlQUFBLENBQU9DLFNBQVAsQ0FBaUIsSUFBQUMsd0JBQUEsRUFBa0IsSUFBbEIsQ0FBakIsQ0FBWjtJQUVBLEtBQUtDLFNBQUwsR0FBaUJuQixJQUFqQjtJQUNBLEtBQUtvQixTQUFMLEdBQWlCbkIsSUFBakI7SUFDQSxLQUFLUSxHQUFMLEdBQVdBLEdBQVg7SUFDQSxLQUFLRCxPQUFMLEdBQWVBLE9BQWY7SUFDQSxLQUFLYSxJQUFMLEdBQVksSUFBWjtJQUNBLEtBQUtuQixtQkFBTCxHQUEyQkEsbUJBQTNCO0lBQ0EsS0FBS29CLFlBQUwsR0FBb0JuQixVQUFwQjtJQUNBLEtBQUtDLGFBQUwsR0FBcUJBLGFBQXJCO0lBQ0EsS0FBS0csV0FBTCxHQUFtQkEsV0FBbkI7SUFDQSxLQUFLRCxRQUFMLEdBQWdCQSxRQUFoQjtJQUNBLEtBQUtpQixrQkFBTCxHQUEwQixLQUExQjtJQUNBLEtBQUtDLEtBQUwsR0FBYTdCLFlBQVksQ0FBQzhCLGFBQTFCO0lBQ0EsS0FBS0MsT0FBTCxHQUFlLElBQUlDLGVBQUosQ0FBWTtNQUN6QkMsTUFBTSxFQUFFLEtBQUtULFNBRFk7TUFFekJsQixJQUFJLEVBQUUsS0FBS21CLFNBRmM7TUFHekJTLEdBQUcsRUFBRSxLQUFLZDtJQUhlLENBQVosQ0FBZjtJQUtBLEtBQUtMLE9BQUwsR0FBZUEsT0FBZjtJQUNBLEtBQUtDLE9BQUwsR0FBZUEsT0FBZjtJQUNBLEtBQUtDLGlCQUFMLEdBQXlCLENBQUMsQ0FBQ0EsaUJBQTNCO0lBQ0EsS0FBS2tCLGFBQUwsR0FBcUJoQixxQkFBcUIsR0FDdEMsSUFBSWlCLHNCQUFKLENBQThCO01BQUVDLGVBQWUsRUFBRSxLQUFLNUI7SUFBeEIsQ0FBOUIsQ0FEc0MsR0FFdEMsSUFGSjtJQUdBLEtBQUtTLE9BQUwsR0FBZUEsT0FBZjtJQUNBLEtBQUtvQixZQUFMLEdBQW9CLEVBQXBCO0lBQ0EsS0FBS0MsZUFBTCxHQUF1QkMsaUJBQUEsQ0FBVUMsT0FBakM7RUFDRDs7RUFFTSxJQUFIUCxHQUFHLEdBQUk7SUFDVCxPQUFPLEtBQUtkLElBQVo7RUFDRDs7RUFFc0IsTUFBakJzQixpQkFBaUIsR0FBSTtJQUN6QixJQUFJQyxPQUFPLEdBQUdDLGVBQUEsQ0FBRUMsU0FBRixDQUFZQyxrQ0FBWixDQUFkOztJQUNBLElBQUksS0FBS2xDLFdBQVQsRUFBc0I7TUFDcEIsS0FBS3NCLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQix3REFBdUQsS0FBS25DLFdBQVksR0FBeEY7O01BQ0EsSUFBSSxFQUFDLE1BQU1vQyxXQUFBLENBQUdDLE1BQUgsQ0FBVSxLQUFLckMsV0FBZixDQUFQLENBQUosRUFBd0M7UUFDdEMsS0FBS3NCLEdBQUwsQ0FBU2dCLElBQVQsQ0FBZSxxQkFBb0IsS0FBS3RDLFdBQVksR0FBcEQ7UUFDQSxLQUFLc0IsR0FBTCxDQUFTaUIsSUFBVCxDQUFjLHVEQUFkO01BQ0QsQ0FIRCxNQUdPO1FBQ0wsSUFBSTtVQUNGUixPQUFPLEdBQUdTLElBQUksQ0FBQ0MsS0FBTCxDQUFXLE1BQU1MLFdBQUEsQ0FBR00sUUFBSCxDQUFZLEtBQUsxQyxXQUFqQixFQUE4QixNQUE5QixDQUFqQixDQUFWO1FBQ0QsQ0FGRCxDQUVFLE9BQU8yQyxHQUFQLEVBQVk7VUFDWixLQUFLckIsR0FBTCxDQUFTZ0IsSUFBVCxDQUFlLCtCQUE4QixLQUFLdEMsV0FBWSxNQUFLMkMsR0FBRyxDQUFDQyxPQUFRLEVBQS9FO1VBQ0EsS0FBS3RCLEdBQUwsQ0FBU2lCLElBQVQsQ0FBYyx1REFBZDtRQUNEO01BQ0Y7SUFDRixDQWJELE1BYU87TUFDTCxLQUFLakIsR0FBTCxDQUFTYSxLQUFULENBQWUsK0NBQWY7SUFDRDs7SUFHRCxLQUFLLE1BQU0sQ0FBQ1UsU0FBRCxFQUFZQyxhQUFaLENBQVgsSUFBeUNkLGVBQUEsQ0FBRWUsT0FBRixDQUFVaEIsT0FBVixDQUF6QyxFQUE2RDtNQUMzRCxNQUFNaUIsY0FBYyxHQUFHQyxlQUFBLENBQU9DLE1BQVAsQ0FBY0osYUFBZCxDQUF2Qjs7TUFDQSxJQUFJRSxjQUFKLEVBQW9CO1FBQ2xCakIsT0FBTyxDQUFDYyxTQUFELENBQVAsR0FBcUJHLGNBQWMsQ0FBQ0csT0FBcEM7TUFDRCxDQUZELE1BRU87UUFDTCxLQUFLN0IsR0FBTCxDQUFTaUIsSUFBVCxDQUFlLElBQUdPLGFBQWMsOENBQWhDO01BQ0Q7SUFDRjs7SUFDRCxPQUFPZixPQUFQO0VBQ0Q7O0VBRXFCLE1BQWhCcUIsZ0JBQWdCLENBQUVyQixPQUFGLEVBQVc7SUFFL0IsTUFBTXNCLFdBQVcsR0FBRyxNQUFNakIsV0FBQSxDQUFHa0IsSUFBSCxDQUFRLEdBQVIsRUFBYTtNQUNyQ0MsR0FBRyxFQUFFLEtBQUsxRCxhQUQyQjtNQUVyQzJELE1BQU0sRUFBRSxLQUY2QjtNQUdyQ0MsS0FBSyxFQUFFLElBSDhCO01BSXJDQyxRQUFRLEVBQUU7SUFKMkIsQ0FBYixDQUExQjtJQU1BLEtBQUtwQyxHQUFMLENBQVNhLEtBQVQsQ0FBZ0IsU0FBUXdCLGFBQUEsQ0FBS0MsU0FBTCxDQUFlLFlBQWYsRUFBNkJQLFdBQVcsQ0FBQ1EsTUFBekMsRUFBaUQsSUFBakQsQ0FBdUQsR0FBaEUsR0FDWixPQUFNLEtBQUtoRSxhQUFjLEdBRDVCO0lBRUEsTUFBTWlFLEdBQUcsR0FBRyxDQUFDLE1BQU0sSUFBQUMsa0JBQUEsRUFBU1YsV0FBVCxFQUFzQixNQUFPekQsVUFBUCxJQUFzQjtNQUM3RCxNQUFNb0UsUUFBUSxHQUFHLENBQUM7UUFBQ3BCLE9BQUQ7UUFBVXFCLE1BQU0sR0FBRyxJQUFuQjtRQUF5QkMsTUFBTSxHQUFHO01BQWxDLENBQUQsS0FBNkM7UUFDNUQsSUFBSUMsTUFBTSxHQUFJLHdDQUF1Q0MsYUFBQSxDQUFLQyxRQUFMLENBQWN6RSxVQUFkLENBQTBCLHlCQUFsRSxHQUNWLGlHQUFnR2dELE9BQVEsRUFEM0c7O1FBRUEsSUFBSXFCLE1BQUosRUFBWTtVQUNWRSxNQUFNLElBQUssYUFBWUYsTUFBTyxFQUE5QjtRQUNEOztRQUNELElBQUlDLE1BQUosRUFBWTtVQUNWQyxNQUFNLElBQUssYUFBWUQsTUFBTyxFQUE5QjtRQUNEOztRQUNELEtBQUs1QyxHQUFMLENBQVNnQixJQUFULENBQWM2QixNQUFkO1FBQ0EsT0FBTyxJQUFQO01BQ0QsQ0FYRDs7TUFhQSxJQUFJRixNQUFKO01BQ0EsSUFBSUMsTUFBSjs7TUFDQSxJQUFJO1FBQ0YsQ0FBQztVQUFDRCxNQUFEO1VBQVNDO1FBQVQsSUFBbUIsTUFBTSxJQUFBSSxrQkFBQSxFQUFLMUUsVUFBTCxFQUFpQixDQUFDLFdBQUQsQ0FBakIsRUFBZ0M7VUFDeEQyRSxPQUFPLEVBQUVwRjtRQUQrQyxDQUFoQyxDQUExQjtNQUdELENBSkQsQ0FJRSxPQUFPd0QsR0FBUCxFQUFZO1FBQ1osSUFBSSxDQUFDLENBQUNBLEdBQUcsQ0FBQ0MsT0FBSixJQUFlLEVBQWhCLEVBQW9CNEIsUUFBcEIsQ0FBNkIsV0FBN0IsQ0FBRCxJQUE4QyxDQUFDLENBQUM3QixHQUFHLENBQUNzQixNQUFKLElBQWMsRUFBZixFQUFtQk8sUUFBbkIsQ0FBNEIsdUJBQTVCLENBQW5ELEVBQXlHO1VBQ3ZHLE9BQU9SLFFBQVEsQ0FBQ3JCLEdBQUQsQ0FBZjtRQUNEOztRQUlEc0IsTUFBTSxHQUFHdEIsR0FBRyxDQUFDc0IsTUFBYjtNQUNEOztNQUVELE1BQU1RLEtBQUssR0FBRyxtQ0FBbUNILElBQW5DLENBQXdDTCxNQUF4QyxDQUFkOztNQUNBLElBQUksQ0FBQ1EsS0FBTCxFQUFZO1FBQ1YsT0FBT1QsUUFBUSxDQUFDO1VBQUNwQixPQUFPLEVBQUUsaUNBQVY7VUFBNkNxQixNQUE3QztVQUFxREM7UUFBckQsQ0FBRCxDQUFmO01BQ0Q7O01BQ0QsSUFBSWYsT0FBTyxHQUFHc0IsS0FBSyxDQUFDLENBQUQsQ0FBbkI7TUFDQSxJQUFJQyxnQkFBZ0IsR0FBRzNDLE9BQU8sQ0FBQ29CLE9BQUQsQ0FBOUI7O01BQ0EsTUFBTUgsY0FBYyxHQUFHQyxlQUFBLENBQU9DLE1BQVAsQ0FBY0MsT0FBZCxDQUF2Qjs7TUFDQSxJQUFJSCxjQUFKLEVBQW9CO1FBRWxCLElBQUlBLGNBQWMsQ0FBQzJCLEtBQWYsR0FBdUJqRyxtQ0FBM0IsRUFBZ0U7VUFDOUR5RSxPQUFPLEdBQUksR0FBRUgsY0FBYyxDQUFDMkIsS0FBTSxJQUFHM0IsY0FBYyxDQUFDNEIsS0FBTSxFQUExRDtVQUNBRixnQkFBZ0IsR0FBRzNDLE9BQU8sQ0FBQ29CLE9BQUQsQ0FBMUI7UUFDRDs7UUFDRCxJQUFJLENBQUN1QixnQkFBRCxJQUFxQjFCLGNBQWMsQ0FBQzJCLEtBQWYsSUFBd0JqRyxtQ0FBakQsRUFBc0Y7VUFFcEZnRyxnQkFBZ0IsR0FBSSxHQUFFMUIsY0FBYyxDQUFDMkIsS0FBTSxFQUEzQztRQUNEO01BQ0Y7O01BQ0QsT0FBTztRQUNML0UsVUFESztRQUVMdUQsT0FGSztRQUdMdUI7TUFISyxDQUFQO0lBS0QsQ0FyRGtCLENBQVAsRUFzRFRHLE1BdERTLENBc0REQyxFQUFELElBQVEsQ0FBQyxDQUFDQSxFQXREUixFQXVEVEMsSUF2RFMsQ0F1REosQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLEtBQVUsSUFBQUMsd0JBQUEsRUFBZ0JELENBQUMsQ0FBQzlCLE9BQWxCLEVBQTJCNkIsQ0FBQyxDQUFDN0IsT0FBN0IsQ0F2RE4sQ0FBWjs7SUF3REEsSUFBSW5CLGVBQUEsQ0FBRW1ELE9BQUYsQ0FBVXJCLEdBQVYsQ0FBSixFQUFvQjtNQUNsQixLQUFLeEMsR0FBTCxDQUFTaUIsSUFBVCxDQUFlLG1DQUFrQyxLQUFLMUMsYUFBYyxHQUFwRTtNQUNBLE9BQU9pRSxHQUFQO0lBQ0Q7O0lBQ0QsS0FBS3hDLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQixvREFBaEI7O0lBQ0EsS0FBSyxNQUFNMkMsRUFBWCxJQUFpQmhCLEdBQWpCLEVBQXNCO01BQ3BCLEtBQUt4QyxHQUFMLENBQVNhLEtBQVQsQ0FBZ0IsUUFBTzJDLEVBQUUsQ0FBQ2xGLFVBQVcsZUFBY2tGLEVBQUUsQ0FBQzNCLE9BQVEsOEJBQTZCMkIsRUFBRSxDQUFDSixnQkFBSCxHQUFzQkksRUFBRSxDQUFDSixnQkFBekIsR0FBNEMsU0FBVSxJQUFqSjtJQUNEOztJQUNELE9BQU9aLEdBQVA7RUFDRDs7RUFFcUIsTUFBaEJzQixnQkFBZ0IsR0FBSTtJQUFBOztJQUl4QixxQkFBSSxLQUFLOUUsT0FBVCwwQ0FBSSxjQUFjaUMsSUFBbEIsRUFBd0I7TUFBQTs7TUFDdEIsS0FBS2pCLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQiw0Q0FBRCxrQkFBNEMsS0FBSzdCLE9BQWpELDBFQUE0QyxlQUFjaUMsSUFBMUQsd0RBQTRDLG9CQUFvQjhDLE9BQVEsRUFBdkY7SUFDRDs7SUFDRCxNQUFNQyxZQUFZLEdBQUdwRyxlQUFlLENBQUNvRixJQUFoQixtQkFBcUIsS0FBS2hFLE9BQTFCLDBFQUFxQixlQUFjaUMsSUFBbkMsd0RBQXFCLG9CQUFvQjhDLE9BQXpDLENBQXJCOztJQUNBLElBQUlDLFlBQUosRUFBa0I7TUFDaEIsTUFBTXRDLGNBQWMsR0FBR0MsZUFBQSxDQUFPQyxNQUFQLENBQWNvQyxZQUFZLENBQUMsQ0FBRCxDQUExQixDQUF2Qjs7TUFDQSxJQUFJdEMsY0FBSixFQUFvQjtRQUNsQixPQUFPQSxjQUFQO01BQ0Q7SUFDRjs7SUFFRCxJQUFJRixhQUFKOztJQUdBLElBQUksS0FBSy9DLFFBQUwsS0FBa0JoQix1QkFBdEIsRUFBK0M7TUFDN0MsS0FBSyxNQUFNZ0IsUUFBWCxJQUF1QmYsa0JBQXZCLEVBQTJDO1FBQ3pDOEQsYUFBYSxHQUFHLE1BQU0sSUFBQXNDLHVCQUFBLEVBQWlCLEtBQUtsRixHQUF0QixFQUEyQkgsUUFBM0IsQ0FBdEI7O1FBQ0EsSUFBSStDLGFBQUosRUFBbUI7VUFDakIsS0FBSy9DLFFBQUwsR0FBZ0JBLFFBQWhCO1VBQ0EsT0FBT2tELGVBQUEsQ0FBT0MsTUFBUCxDQUFjSixhQUFkLENBQVA7UUFDRDtNQUNGOztNQUNELE9BQU8sSUFBUDtJQUNEOztJQUdELElBQUksS0FBSzVDLEdBQVQsRUFBYztNQUNaLE1BQU1xRixRQUFRLEdBQUcsTUFBTSxLQUFLckYsR0FBTCxDQUFTc0YsV0FBVCxFQUF2Qjs7TUFDQSxJQUFJRCxRQUFRLElBQUksRUFBWixJQUFrQkEsUUFBUSxJQUFJLEVBQTlCLElBQ0EsQ0FBQ3hHLHVCQUFELEVBQTBCLEdBQUdDLGtCQUE3QixFQUFpRHdGLFFBQWpELENBQTBELEtBQUt6RSxRQUEvRCxDQURKLEVBQzhFO1FBQzVFLEtBQUtBLFFBQUwsR0FBZ0JqQixnQkFBaEI7TUFDRDtJQUNGOztJQUdELElBQUksQ0FBQyxLQUFLaUIsUUFBVixFQUFvQjtNQUVsQixLQUFLQSxRQUFMLEdBQWdCakIsZ0JBQWhCOztNQUdBLEtBQUssTUFBTWlCLFFBQVgsSUFBdUJmLGtCQUF2QixFQUEyQztRQUN6QzhELGFBQWEsR0FBRyxNQUFNLElBQUFzQyx1QkFBQSxFQUFpQixLQUFLbEYsR0FBdEIsRUFBMkJILFFBQTNCLENBQXRCOztRQUNBLElBQUkrQyxhQUFKLEVBQW1CO1VBQ2pCLEtBQUsvQyxRQUFMLEdBQWdCQSxRQUFoQjtVQUNBO1FBQ0Q7TUFDRjtJQUNGOztJQUdELElBQUksQ0FBQytDLGFBQUwsRUFBb0I7TUFDbEJBLGFBQWEsR0FBRyxNQUFNLElBQUFzQyx1QkFBQSxFQUFpQixLQUFLbEYsR0FBdEIsRUFBMkIsS0FBS0gsUUFBaEMsQ0FBdEI7SUFDRDs7SUFHRCxPQUFPK0MsYUFBYSxHQUFHRyxlQUFBLENBQU9DLE1BQVAsQ0FBY0osYUFBZCxDQUFILEdBQWtDLElBQXREO0VBQ0Q7O0VBRXlCLE1BQXBCMkMsb0JBQW9CLENBQUVDLFVBQUYsRUFBYztJQUN0QyxJQUFJQyx5QkFBeUIsR0FBRyxJQUFoQzs7SUFDQSxJQUFJLE1BQU12RCxXQUFBLENBQUdDLE1BQUgsQ0FBVSxLQUFLckMsV0FBZixDQUFWLEVBQXVDO01BQ3JDLElBQUk7UUFDRixNQUFNb0MsV0FBQSxDQUFHd0QsU0FBSCxDQUFhLEtBQUs1RixXQUFsQixFQUErQndDLElBQUksQ0FBQ3FELFNBQUwsQ0FBZUgsVUFBZixFQUEyQixJQUEzQixFQUFpQyxDQUFqQyxDQUEvQixFQUFvRSxNQUFwRSxDQUFOO1FBQ0FDLHlCQUF5QixHQUFHLEtBQTVCO01BQ0QsQ0FIRCxDQUdFLE9BQU9HLENBQVAsRUFBVTtRQUNWLEtBQUt4RSxHQUFMLENBQVNnQixJQUFULENBQWUsd0RBQXVELEtBQUt0QyxXQUFZLEtBQXpFLEdBQ1gsMEVBQXlFOEYsQ0FBQyxDQUFDbEQsT0FBUSxFQUR0RjtNQUVEO0lBQ0Y7O0lBQ0QsSUFBSStDLHlCQUFKLEVBQStCO01BQzdCSSxNQUFNLENBQUNDLE1BQVAsQ0FBYzlELGtDQUFkLEVBQTJDd0QsVUFBM0M7SUFDRDtFQUNGOztFQUU4QixNQUF6Qk8seUJBQXlCLEdBQUk7SUFDakMsSUFBSSxDQUFDLEtBQUsvRixHQUFWLEVBQWU7TUFDYixPQUFPLE1BQU0sSUFBQWdHLGdDQUFBLEdBQWI7SUFDRDs7SUFFRCxNQUFNbkUsT0FBTyxHQUFHLE1BQU0sS0FBS0QsaUJBQUwsRUFBdEI7O0lBQ0EsSUFBSSxDQUFDRSxlQUFBLENBQUVtRCxPQUFGLENBQVVwRCxPQUFWLENBQUwsRUFBeUI7TUFDdkIsS0FBS1QsR0FBTCxDQUFTYSxLQUFULENBQWdCLHlDQUF3Q0gsZUFBQSxDQUFFbUUsTUFBRixDQUFTcEUsT0FBVCxFQUFrQixDQUFsQixDQUFxQixFQUE3RTtJQUNEOztJQUVELElBQUlxRSxjQUFjLEdBQUcsS0FBckI7O0lBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsTUFBT3ZELGFBQVAsSUFBeUI7TUFDakRzRCxjQUFjLEdBQUcsSUFBakI7TUFDQSxNQUFNRSxnQkFBZ0IsR0FBRyxNQUFNLEtBQUsvRSxhQUFMLENBQW1CZ0YsZUFBbkIsRUFBL0I7TUFDQSxLQUFLakYsR0FBTCxDQUFTYSxLQUFULENBQWUsaURBQ2JLLElBQUksQ0FBQ3FELFNBQUwsQ0FBZVMsZ0JBQWYsRUFBaUMsSUFBakMsRUFBdUMsQ0FBdkMsQ0FERjtNQUVBLE1BQU1FLFVBQVUsR0FBRyxNQUFNLEtBQUtqRixhQUFMLENBQW1Ca0YsV0FBbkIsQ0FBK0I7UUFDdERDLGlCQUFpQixFQUFFNUQsYUFBYSxDQUFDNkI7TUFEcUIsQ0FBL0IsQ0FBekI7O01BR0EsSUFBSTNDLGVBQUEsQ0FBRW1ELE9BQUYsQ0FBVXFCLFVBQVYsQ0FBSixFQUEyQjtRQUN6QixPQUFPLEtBQVA7TUFDRDs7TUFDRCxNQUFNRywwQkFBMEIsR0FBR0gsVUFBVSxDQUFDSSxNQUFYLENBQWtCLENBQUNDLEdBQUQsRUFBTUMsQ0FBTixLQUFZO1FBQy9ELE1BQU07VUFBQzNELE9BQUQ7VUFBVXVEO1FBQVYsSUFBK0JKLGdCQUFnQixDQUFDUSxDQUFELENBQXJEO1FBQ0FELEdBQUcsQ0FBQzFELE9BQUQsQ0FBSCxHQUFldUQsaUJBQWY7UUFDQSxPQUFPRyxHQUFQO01BQ0QsQ0FKa0MsRUFJaEMsRUFKZ0MsQ0FBbkM7TUFLQWQsTUFBTSxDQUFDQyxNQUFQLENBQWNqRSxPQUFkLEVBQXVCNEUsMEJBQXZCO01BQ0EsTUFBTSxLQUFLbEIsb0JBQUwsQ0FBMEIxRCxPQUExQixDQUFOO01BQ0EsT0FBTyxJQUFQO0lBQ0QsQ0FuQkQ7O0lBcUJBLEdBQUc7TUFDRCxNQUFNK0IsR0FBRyxHQUFHLE1BQU0sS0FBS1YsZ0JBQUwsQ0FBc0JyQixPQUF0QixDQUFsQjtNQUVBLE1BQU1nRixlQUFlLEdBQUcsRUFBeEI7O01BQ0EsS0FBSyxNQUFNO1FBQUM1RCxPQUFEO1FBQVV1QjtNQUFWLENBQVgsSUFBMENaLEdBQTFDLEVBQStDO1FBQzdDLElBQUksQ0FBQ1ksZ0JBQUQsSUFBcUIzQyxPQUFPLENBQUNvQixPQUFELENBQWhDLEVBQTJDO1VBQ3pDO1FBQ0Q7O1FBQ0QsTUFBTTZELFVBQVUsR0FBRy9ELGVBQUEsQ0FBT0MsTUFBUCxDQUFjQyxPQUFkLENBQW5COztRQUNBLElBQUksQ0FBQzZELFVBQUQsSUFBZUEsVUFBVSxDQUFDckMsS0FBWCxHQUFtQmpHLG1DQUF0QyxFQUEyRTtVQUN6RTtRQUNEOztRQUVEcUksZUFBZSxDQUFDNUQsT0FBRCxDQUFmLEdBQTJCdUIsZ0JBQTNCO01BQ0Q7O01BQ0QsSUFBSSxDQUFDMUMsZUFBQSxDQUFFbUQsT0FBRixDQUFVNEIsZUFBVixDQUFMLEVBQWlDO1FBQy9CLEtBQUt6RixHQUFMLENBQVNpQixJQUFULENBQWUsU0FBUW9CLGFBQUEsQ0FBS0MsU0FBTCxDQUFlLGNBQWYsRUFBK0I1QixlQUFBLENBQUVpRixJQUFGLENBQU9GLGVBQVAsQ0FBL0IsRUFBd0QsSUFBeEQsQ0FBOEQsSUFBdkUsR0FDWCxTQUFRL0UsZUFBQSxDQUFFaUYsSUFBRixDQUFPRixlQUFQLE1BQTRCLENBQTVCLEdBQWdDLElBQWhDLEdBQXVDLEtBQU0sMENBRDFDLEdBRVp2RSxJQUFJLENBQUNxRCxTQUFMLENBQWVrQixlQUFmLENBRkY7UUFHQSxNQUFNLEtBQUt0QixvQkFBTCxDQUEwQk0sTUFBTSxDQUFDQyxNQUFQLENBQWNqRSxPQUFkLEVBQXVCZ0YsZUFBdkIsQ0FBMUIsQ0FBTjtNQUNEOztNQUVELElBQUksS0FBSzFHLGlCQUFULEVBQTRCO1FBQzFCLElBQUkyQixlQUFBLENBQUVtRCxPQUFGLENBQVVyQixHQUFWLENBQUosRUFBb0I7VUFDbEIsS0FBS3hDLEdBQUwsQ0FBUzRGLGFBQVQsQ0FBd0IsMEVBQUQsR0FDcEIsNkRBREg7UUFFRDs7UUFDRCxNQUFNO1VBQUMvRCxPQUFEO1VBQVV2RDtRQUFWLElBQXdCa0UsR0FBRyxDQUFDLENBQUQsQ0FBakM7UUFDQSxLQUFLeEMsR0FBTCxDQUFTZ0IsSUFBVCxDQUFlLHdFQUF1RWEsT0FBUSxTQUFRdkQsVUFBVyxJQUFqSDtRQUNBLEtBQUswQixHQUFMLENBQVNnQixJQUFULENBQWUsNkVBQWY7UUFDQSxPQUFPMUMsVUFBUDtNQUNEOztNQUVELE1BQU1rRCxhQUFhLEdBQUcsTUFBTSxLQUFLc0MsZ0JBQUwsRUFBNUI7O01BQ0EsSUFBSSxDQUFDdEMsYUFBTCxFQUFvQjtRQUVsQixJQUFJZCxlQUFBLENBQUVtRCxPQUFGLENBQVVyQixHQUFWLENBQUosRUFBb0I7VUFDbEIsS0FBS3hDLEdBQUwsQ0FBUzRGLGFBQVQsQ0FBd0IsMEVBQUQsR0FDcEIsaURBREg7UUFFRDs7UUFDRCxNQUFNO1VBQUMvRCxPQUFEO1VBQVV2RDtRQUFWLElBQXdCa0UsR0FBRyxDQUFDLENBQUQsQ0FBakM7UUFDQSxLQUFLeEMsR0FBTCxDQUFTZ0IsSUFBVCxDQUFlLHlEQUF3RGEsT0FBUSxRQUFPdkQsVUFBVyxHQUFqRztRQUNBLE9BQU9BLFVBQVA7TUFDRDs7TUFDRCxLQUFLMEIsR0FBTCxDQUFTYSxLQUFULENBQWdCLHdCQUF1QixLQUFLcEMsUUFBUyxjQUFhK0MsYUFBYyxHQUFoRjtNQUVBLE1BQU1xRSxlQUFlLEdBQUdyRCxHQUFHLENBQUNlLE1BQUosQ0FBVyxDQUFDO1FBQUNIO01BQUQsQ0FBRCxLQUF3QjtRQUN6RCxNQUFNMEMsaUJBQWlCLEdBQUcxQyxnQkFBZ0IsSUFBSXpCLGVBQUEsQ0FBT0MsTUFBUCxDQUFjd0IsZ0JBQWQsQ0FBOUM7O1FBQ0EsSUFBSSxDQUFDMEMsaUJBQUwsRUFBd0I7VUFDdEIsT0FBTyxLQUFQO1FBQ0Q7O1FBRUQsT0FBT3RFLGFBQWEsQ0FBQzZCLEtBQWQsR0FBc0JqRyxtQ0FBdEIsR0FDSDBJLGlCQUFpQixDQUFDekMsS0FBbEIsS0FBNEI3QixhQUFhLENBQUM2QixLQUR2QyxHQUVIMUIsZUFBQSxDQUFPb0UsR0FBUCxDQUFXdkUsYUFBWCxFQUEwQnNFLGlCQUExQixDQUZKO01BR0QsQ0FUdUIsQ0FBeEI7O01BVUEsSUFBSXBGLGVBQUEsQ0FBRW1ELE9BQUYsQ0FBVWdDLGVBQVYsQ0FBSixFQUFnQztRQUM5QixJQUFJLEtBQUs1RixhQUFMLElBQXNCLENBQUM2RSxjQUEzQixFQUEyQztVQUN6QyxJQUFJO1lBQ0YsSUFBSSxNQUFNQyxpQkFBaUIsQ0FBQ3ZELGFBQUQsQ0FBM0IsRUFBNEM7Y0FDMUM7WUFDRDtVQUNGLENBSkQsQ0FJRSxPQUFPZ0QsQ0FBUCxFQUFVO1lBQ1YsS0FBS3hFLEdBQUwsQ0FBU2dCLElBQVQsQ0FBZSxxRUFBb0VnRixhQUFPLElBQTVFLEdBQ1p4QixDQUFDLENBQUNsRCxPQURKO1lBRUEsS0FBS3RCLEdBQUwsQ0FBU2EsS0FBVCxDQUFlMkQsQ0FBQyxDQUFDeUIsS0FBakI7VUFDRDtRQUNGOztRQUNELE1BQU1DLHNCQUFzQixHQUMxQiw4RUFERjtRQUVBLE1BQU0sSUFBSUMsS0FBSixDQUFXLG1EQUFrRDNFLGFBQWMsS0FBakUsSUFDYixDQUFDLEtBQUt2QixhQUFOLEdBQXVCLEdBQUVpRyxzQkFBdUIsSUFBaEQsR0FBc0QsRUFEekMsSUFFYixPQUFNdkkscUJBQXNCLG1CQUZ6QixDQUFOO01BR0Q7O01BRUQsTUFBTXlJLE9BQU8sR0FBR1AsZUFBZSxDQUFDLENBQUQsQ0FBZixDQUFtQnZILFVBQW5DO01BQ0EsS0FBSzBCLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQixTQUFRd0IsYUFBQSxDQUFLQyxTQUFMLENBQWUsWUFBZixFQUE2QnVELGVBQWUsQ0FBQ3RELE1BQTdDLEVBQXFELElBQXJELENBQTJELEdBQXBFLEdBQ1osaUNBQWdDZixhQUFjLGtDQUFpQzRFLE9BQVEsSUFEMUY7TUFFQSxLQUFLcEcsR0FBTCxDQUFTYSxLQUFULENBQWUsb0ZBQ2IscUJBREY7TUFFQSxPQUFPdUYsT0FBUDtJQUVELENBbEZELFFBa0ZTLElBbEZUO0VBbUZEOztFQUV5QixNQUFwQkMsb0JBQW9CLEdBQUk7SUFDNUIsSUFBSSxLQUFLM0csa0JBQVQsRUFBNkI7O0lBSzdCLElBQUksQ0FBQyxLQUFLRCxZQUFWLEVBQXdCO01BQ3RCLEtBQUtBLFlBQUwsR0FBb0IsS0FBS3BCLG1CQUFMLEdBQ2hCLE1BQU0sSUFBQXVHLGdDQUFBLEdBRFUsR0FFaEIsTUFBTSxLQUFLRCx5QkFBTCxFQUZWO0lBR0Q7O0lBRUQsSUFBSSxFQUFDLE1BQU03RCxXQUFBLENBQUdDLE1BQUgsQ0FBVSxLQUFLdEIsWUFBZixDQUFQLENBQUosRUFBeUM7TUFDdkMsTUFBTSxJQUFJMEcsS0FBSixDQUFXLGtEQUFELEdBQ0MsR0FBRSxLQUFLMUcsWUFBYSx5QkFEL0IsQ0FBTjtJQUVEOztJQUNELEtBQUtDLGtCQUFMLEdBQTBCLElBQTFCO0lBQ0EsS0FBS00sR0FBTCxDQUFTaUIsSUFBVCxDQUFlLCtCQUE4QixLQUFLeEIsWUFBYSxFQUEvRDtFQUNEOztFQUVENkcsWUFBWSxDQUFFL0UsU0FBUyxHQUFHLElBQWQsRUFBb0I7SUFDOUIsTUFBTUcsY0FBYyxHQUFHQyxlQUFBLENBQU9DLE1BQVAsQ0FBY0wsU0FBZCxDQUF2Qjs7SUFDQSxJQUFJLENBQUNHLGNBQUQsSUFBbUJBLGNBQWMsQ0FBQzJCLEtBQWYsR0FBdUIvRiwrQkFBOUMsRUFBK0U7TUFDN0UsS0FBSzBDLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQixtQkFBa0JVLFNBQVUsMkJBQTBCakIsaUJBQUEsQ0FBVWlHLEdBQUksYUFBckUsR0FDWixpQkFBZ0JqRyxpQkFBQSxDQUFVQyxPQUFRLEVBRHJDO01BRUE7SUFDRDs7SUFDRCxNQUFNaUcsYUFBYSxHQUFHLElBQUFDLDRCQUFBLEVBQVksS0FBS3JHLFlBQWpCLEVBQStCLGVBQS9CLEVBQWdELEVBQWhELENBQXRCOztJQUNBLElBQUlvRyxhQUFhLENBQUNFLEdBQWQsS0FBc0IsS0FBMUIsRUFBaUM7TUFDL0IsS0FBSzFHLEdBQUwsQ0FBU2lCLElBQVQsQ0FBZSxtQkFBa0JNLFNBQVUsYUFBWWpCLGlCQUFBLENBQVVpRyxHQUFJLGFBQXZELEdBQ1gsT0FBTWpHLGlCQUFBLENBQVVDLE9BQVEsb0NBRDNCO01BRUE7SUFDRDs7SUFDRCxLQUFLRixlQUFMLEdBQXVCQyxpQkFBQSxDQUFVaUcsR0FBakM7SUFJQSxLQUFLbkcsWUFBTCxHQUFvQixJQUFBdUcsOEJBQUEsRUFBYyxLQUFLdkcsWUFBbkIsQ0FBcEI7RUFDRDs7RUFFVSxNQUFMd0csS0FBSyxDQUFFQyxJQUFGLEVBQVFDLGlCQUFpQixHQUFHLElBQTVCLEVBQWtDO0lBQzNDLEtBQUsxRyxZQUFMLEdBQW9CTSxlQUFBLENBQUVDLFNBQUYsQ0FBWWtHLElBQVosQ0FBcEI7SUFHQSxLQUFLekcsWUFBTCxDQUFrQjJHLFlBQWxCLEdBQWlDckcsZUFBQSxDQUFFQyxTQUFGLENBQVksSUFBQThGLDRCQUFBLEVBQVlJLElBQVosRUFBa0IsY0FBbEIsRUFBa0MsRUFBbEMsQ0FBWixDQUFqQzs7SUFDQSxJQUFJbkcsZUFBQSxDQUFFbUQsT0FBRixDQUFVLEtBQUt6RCxZQUFMLENBQWtCMkcsWUFBbEIsQ0FBK0JDLE9BQXpDLENBQUosRUFBdUQ7TUFDckQsS0FBSzVHLFlBQUwsQ0FBa0IyRyxZQUFsQixDQUErQkMsT0FBL0IsR0FBeUMsS0FBekM7SUFDRDs7SUFFRCxJQUFJRixpQkFBSixFQUF1QjtNQUNyQixLQUFLRyxXQUFMLENBQWlCbkosWUFBWSxDQUFDb0osY0FBOUI7SUFDRDs7SUFFRCxNQUFNaEosSUFBSSxHQUFHLENBQUUsVUFBUyxLQUFLcUIsU0FBVSxFQUExQixDQUFiOztJQUNBLElBQUksS0FBS1gsR0FBTCxJQUFZLEtBQUtBLEdBQUwsQ0FBU3VJLE9BQXpCLEVBQWtDO01BQ2hDakosSUFBSSxDQUFDa0osSUFBTCxDQUFXLGNBQWEsS0FBS3hJLEdBQUwsQ0FBU3VJLE9BQVEsRUFBekM7SUFDRDs7SUFDRCxJQUFJekcsZUFBQSxDQUFFMkcsT0FBRixDQUFVLEtBQUsxSSxPQUFmLENBQUosRUFBNkI7TUFDM0JULElBQUksQ0FBQ2tKLElBQUwsQ0FBVSxHQUFHLEtBQUt6SSxPQUFsQjtJQUNEOztJQUNELElBQUksS0FBS0csT0FBVCxFQUFrQjtNQUNoQlosSUFBSSxDQUFDa0osSUFBTCxDQUFXLGNBQWEsS0FBS3RJLE9BQVEsRUFBckM7SUFDRDs7SUFDRCxJQUFJLEtBQUtDLGlCQUFULEVBQTRCO01BQzFCYixJQUFJLENBQUNrSixJQUFMLENBQVUsdUJBQVY7SUFDRDs7SUFDRGxKLElBQUksQ0FBQ2tKLElBQUwsQ0FBVSxXQUFWOztJQUdBLE1BQU1FLGFBQWEsR0FBSTNFLE1BQUQsSUFBWUEsTUFBTSxDQUFDNEUsVUFBUCxDQUFrQixXQUFsQixDQUFsQzs7SUFFQSxJQUFJQyxjQUFjLEdBQUcsS0FBckI7SUFDQSxJQUFJQyxjQUFKOztJQUNBLElBQUk7TUFDRixNQUFNLEtBQUtwQixvQkFBTCxFQUFOO01BQ0EsTUFBTSxLQUFLcUIsT0FBTCxFQUFOO01BR0EsS0FBS2xJLElBQUwsR0FBWSxJQUFJbUksd0JBQUosQ0FBZSxLQUFLbEksWUFBcEIsRUFBa0N2QixJQUFsQyxDQUFaO01BQ0FzSixjQUFjLEdBQUcsSUFBakI7TUFHQSxLQUFLaEksSUFBTCxDQUFVb0ksRUFBVixDQUFhLFFBQWIsRUFBdUIsQ0FBQ2pGLE1BQUQsRUFBU0MsTUFBVCxLQUFvQjtRQVV6QyxNQUFNaUYsR0FBRyxHQUFHbEYsTUFBTSxHQUFHQyxNQUFyQjtRQUNBLElBQUlPLEtBQUssR0FBRyxvQkFBb0JILElBQXBCLENBQXlCNkUsR0FBekIsQ0FBWjs7UUFDQSxJQUFJMUUsS0FBSixFQUFXO1VBQ1RzRSxjQUFjLEdBQUd0RSxLQUFLLENBQUMsQ0FBRCxDQUF0QjtVQUNBLEtBQUtuRCxHQUFMLENBQVNhLEtBQVQsQ0FBZ0IscUJBQW9CNEcsY0FBZSxHQUFuRDtRQUNEOztRQUtEdEUsS0FBSyxHQUFHLGlDQUFpQ0gsSUFBakMsQ0FBc0M2RSxHQUF0QyxDQUFSOztRQUNBLElBQUkxRSxLQUFKLEVBQVc7VUFDVCxLQUFLbkQsR0FBTCxDQUFTYSxLQUFULENBQWdCLDBCQUF5QnNDLEtBQUssQ0FBQyxDQUFELENBQUksR0FBbEQ7VUFDQSxLQUFLbUQsWUFBTCxDQUFrQm5ELEtBQUssQ0FBQyxDQUFELENBQXZCO1FBQ0Q7O1FBR0QsSUFBSSxLQUFLdEUsT0FBVCxFQUFrQjtVQUNoQixLQUFLLElBQUlpSixJQUFULElBQWlCLENBQUNuRixNQUFNLElBQUksRUFBWCxFQUFlb0YsSUFBZixHQUFzQkMsS0FBdEIsQ0FBNEIsSUFBNUIsQ0FBakIsRUFBb0Q7WUFDbEQsSUFBSSxDQUFDRixJQUFJLENBQUNDLElBQUwsR0FBWXhGLE1BQWpCLEVBQXlCO1lBQ3pCLEtBQUt2QyxHQUFMLENBQVNhLEtBQVQsQ0FBZ0IsWUFBV2lILElBQUssRUFBaEM7VUFDRDs7VUFDRCxLQUFLLElBQUlBLElBQVQsSUFBaUIsQ0FBQ2xGLE1BQU0sSUFBSSxFQUFYLEVBQWVtRixJQUFmLEdBQXNCQyxLQUF0QixDQUE0QixJQUE1QixDQUFqQixFQUFvRDtZQUNsRCxJQUFJLENBQUNGLElBQUksQ0FBQ0MsSUFBTCxHQUFZeEYsTUFBakIsRUFBeUI7WUFDekIsS0FBS3ZDLEdBQUwsQ0FBU2lJLEtBQVQsQ0FBZ0IsWUFBV0gsSUFBSyxFQUFoQztVQUNEO1FBQ0Y7TUFDRixDQXJDRDtNQXdDQSxLQUFLdEksSUFBTCxDQUFVb0ksRUFBVixDQUFhLE1BQWIsRUFBcUIsQ0FBQ00sSUFBRCxFQUFPQyxNQUFQLEtBQWtCO1FBQ3JDWCxjQUFjLEdBQUcsS0FBakI7O1FBQ0EsSUFBSSxLQUFLN0gsS0FBTCxLQUFlN0IsWUFBWSxDQUFDOEIsYUFBNUIsSUFDQSxLQUFLRCxLQUFMLEtBQWU3QixZQUFZLENBQUNzSyxjQUQ1QixJQUVBLEtBQUt6SSxLQUFMLEtBQWU3QixZQUFZLENBQUN1SyxnQkFGaEMsRUFFa0Q7VUFDaEQsTUFBTUMsR0FBRyxHQUFJLDhDQUE2Q0osSUFBSyxZQUFXQyxNQUFPLEVBQWpGO1VBQ0EsS0FBS25JLEdBQUwsQ0FBU2lJLEtBQVQsQ0FBZUssR0FBZjtVQUNBLEtBQUtyQixXQUFMLENBQWlCbkosWUFBWSxDQUFDOEIsYUFBOUI7UUFDRDtNQUNGLENBVEQ7TUFVQSxLQUFLSSxHQUFMLENBQVNpQixJQUFULENBQWUsK0JBQThCLEtBQUt4QixZQUFhLElBQUd2QixJQUFJLENBQUNxSyxJQUFMLENBQVUsR0FBVixDQUFlLEVBQWpGO01BRUEsTUFBTSxLQUFLL0ksSUFBTCxDQUFVb0gsS0FBVixDQUFnQlUsYUFBaEIsQ0FBTjtNQUNBLE1BQU0sS0FBS2tCLGFBQUwsRUFBTjtNQUNBLE1BQU0sS0FBS0MsWUFBTCxFQUFOO0lBQ0QsQ0FoRUQsQ0FnRUUsT0FBT2pFLENBQVAsRUFBVTtNQUNWLEtBQUt4RSxHQUFMLENBQVNhLEtBQVQsQ0FBZTJELENBQWY7TUFDQSxLQUFLa0UsSUFBTCxDQUFVNUssWUFBWSxDQUFDNkssV0FBdkIsRUFBb0NuRSxDQUFwQzs7TUFHQSxJQUFJZ0QsY0FBSixFQUFvQjtRQUNsQixNQUFNLEtBQUtoSSxJQUFMLENBQVVvSixJQUFWLEVBQU47TUFDRDs7TUFFRCxJQUFJdEgsT0FBTyxHQUFHLEVBQWQ7O01BRUEsSUFBSWtELENBQUMsQ0FBQ2xELE9BQUYsQ0FBVTRCLFFBQVYsQ0FBbUIsd0JBQW5CLENBQUosRUFBa0Q7UUFBQTs7UUFDaEQ1QixPQUFPLElBQUksa0dBQVg7O1FBQ0EsSUFBSW1HLGNBQUosRUFBb0I7VUFDbEJuRyxPQUFPLElBQUssaUNBQWdDbUcsY0FBZSxJQUEzRDtRQUNEOztRQUNELE1BQU1vQix5QkFBeUIsR0FBRyx3Q0FBOEI3RixJQUE5QixDQUFtQ3dCLENBQUMsQ0FBQ2xELE9BQXJDLGlEQUFnRCxDQUFoRCxNQUFzRCxFQUF4Rjs7UUFDQSxJQUFJdUgseUJBQUosRUFBK0I7VUFDN0J2SCxPQUFPLElBQUssNENBQTJDdUgseUJBQTBCLElBQWpGO1FBQ0Q7O1FBQ0R2SCxPQUFPLElBQUssVUFBUzNELHFCQUFzQixrQ0FBM0M7TUFDRDs7TUFFRDJELE9BQU8sSUFBSWtELENBQUMsQ0FBQ2xELE9BQWI7TUFDQSxLQUFLdEIsR0FBTCxDQUFTNEYsYUFBVCxDQUF1QnRFLE9BQXZCO0lBQ0Q7RUFDRjs7RUFFRHdILFNBQVMsR0FBSTtJQUNYLE9BQU8sS0FBS25KLEtBQUwsS0FBZTdCLFlBQVksQ0FBQ2lMLFlBQTVCLEdBQTJDLEtBQUtsSixPQUFMLENBQWFpSixTQUF4RCxHQUFvRSxJQUEzRTtFQUNEOztFQUVZLE1BQVBFLE9BQU8sR0FBSTtJQUNmLEtBQUtoSixHQUFMLENBQVNpQixJQUFULENBQWMseUJBQWQ7O0lBQ0EsSUFBSSxLQUFLdEIsS0FBTCxLQUFlN0IsWUFBWSxDQUFDaUwsWUFBaEMsRUFBOEM7TUFDNUMsTUFBTSxJQUFJNUMsS0FBSixDQUFVLHFDQUFWLENBQU47SUFDRDs7SUFDRCxLQUFLYyxXQUFMLENBQWlCbkosWUFBWSxDQUFDdUssZ0JBQTlCO0lBQ0EsTUFBTSxLQUFLTyxJQUFMLENBQVUsS0FBVixDQUFOO0lBQ0EsTUFBTSxLQUFLaEMsS0FBTCxDQUFXLEtBQUt4RyxZQUFoQixFQUE4QixLQUE5QixDQUFOO0VBQ0Q7O0VBRWtCLE1BQWJvSSxhQUFhLEdBQUk7SUFFckIsSUFBSVMsbUJBQW1CLEdBQUcsS0FBMUI7SUFDQSxNQUFNLElBQUFDLHVCQUFBLEVBQWMsRUFBZCxFQUFrQixHQUFsQixFQUF1QixZQUFZO01BQ3ZDLElBQUksS0FBS3ZKLEtBQUwsS0FBZTdCLFlBQVksQ0FBQzhCLGFBQWhDLEVBQStDO1FBRTdDcUosbUJBQW1CLEdBQUcsSUFBdEI7UUFDQTtNQUNEOztNQUNELE1BQU0sS0FBS0UsU0FBTCxFQUFOO0lBQ0QsQ0FQSyxDQUFOOztJQVFBLElBQUlGLG1CQUFKLEVBQXlCO01BQ3ZCLE1BQU0sSUFBSTlDLEtBQUosQ0FBVSxzQ0FBVixDQUFOO0lBQ0Q7RUFDRjs7RUFFYyxNQUFUZ0QsU0FBUyxHQUFJO0lBQ2pCLE9BQU8sTUFBTSxLQUFLdEosT0FBTCxDQUFhdUosT0FBYixDQUFxQixTQUFyQixFQUFnQyxLQUFoQyxDQUFiO0VBQ0Q7O0VBRWlCLE1BQVpYLFlBQVksR0FBSTtJQUNwQixNQUFNWSxXQUFXLEdBQUcsS0FBS2hKLGVBQUwsS0FBeUJDLGlCQUFBLENBQVVpRyxHQUFuQyxHQUNoQjtNQUFDbkcsWUFBWSxFQUFFO1FBQUNrSixXQUFXLEVBQUUsS0FBS2xKO01BQW5CO0lBQWYsQ0FEZ0IsR0FFaEI7TUFBQ21KLG1CQUFtQixFQUFFLEtBQUtuSjtJQUEzQixDQUZKO0lBR0EsS0FBS0osR0FBTCxDQUFTaUIsSUFBVCxDQUFlLFlBQVcsS0FBS1osZUFBZ0IsMkNBQWpDLEdBQ1phLElBQUksQ0FBQ3FELFNBQUwsQ0FBZThFLFdBQWYsRUFBNEIsSUFBNUIsRUFBa0MsQ0FBbEMsQ0FERjtJQUVBLE1BQU0sS0FBS3hKLE9BQUwsQ0FBYXVKLE9BQWIsQ0FBcUIsVUFBckIsRUFBaUMsTUFBakMsRUFBeUNDLFdBQXpDLENBQU47SUFDQSxLQUFLckosR0FBTCxDQUFTd0osTUFBVCxHQUFrQixJQUFBbkssd0JBQUEsRUFBa0IsSUFBbEIsRUFBd0IsS0FBS1EsT0FBTCxDQUFhaUosU0FBckMsQ0FBbEI7SUFDQSxLQUFLN0IsV0FBTCxDQUFpQm5KLFlBQVksQ0FBQ2lMLFlBQTlCO0VBQ0Q7O0VBRVMsTUFBSkgsSUFBSSxDQUFFYSxVQUFVLEdBQUcsSUFBZixFQUFxQjtJQUM3QixJQUFJQSxVQUFKLEVBQWdCO01BQ2QsS0FBS3hDLFdBQUwsQ0FBaUJuSixZQUFZLENBQUNzSyxjQUE5QjtJQUNEOztJQUNELE1BQU1zQixXQUFXLEdBQUcsTUFBT0MsQ0FBUCxJQUFhO01BQy9CLElBQUk7UUFDRixPQUFPLE1BQU1BLENBQUMsRUFBZDtNQUNELENBRkQsQ0FFRSxPQUFPbkYsQ0FBUCxFQUFVO1FBQ1YsS0FBS3hFLEdBQUwsQ0FBU2dCLElBQVQsQ0FBY3dELENBQUMsQ0FBQ2xELE9BQWhCO1FBQ0EsS0FBS3RCLEdBQUwsQ0FBU2EsS0FBVCxDQUFlMkQsQ0FBQyxDQUFDeUIsS0FBakI7TUFDRDtJQUNGLENBUEQ7O0lBUUEsTUFBTXlELFdBQVcsQ0FBQyxNQUFNLEtBQUs3SixPQUFMLENBQWF1SixPQUFiLENBQXFCLEVBQXJCLEVBQXlCLFFBQXpCLENBQVAsQ0FBakI7SUFDQSxNQUFNTSxXQUFXLENBQUMsTUFBTSxLQUFLbEssSUFBTCxDQUFVb0osSUFBVixDQUFlLFNBQWYsRUFBMEIsS0FBMUIsQ0FBUCxDQUFqQjtJQUNBLEtBQUs1SSxHQUFMLENBQVN3SixNQUFULEdBQWtCLElBQUFuSyx3QkFBQSxFQUFrQixJQUFsQixDQUFsQjs7SUFDQSxJQUFJb0ssVUFBSixFQUFnQjtNQUNkLEtBQUt4QyxXQUFMLENBQWlCbkosWUFBWSxDQUFDOEIsYUFBOUI7SUFDRDtFQUNGOztFQUVEcUgsV0FBVyxDQUFFdEgsS0FBRixFQUFTO0lBQ2xCLEtBQUtBLEtBQUwsR0FBYUEsS0FBYjtJQUNBLEtBQUtLLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQixxQkFBb0JsQixLQUFNLEdBQTFDO0lBQ0EsS0FBSytJLElBQUwsQ0FBVTVLLFlBQVksQ0FBQzhMLGFBQXZCLEVBQXNDO01BQUNqSztJQUFELENBQXRDO0VBQ0Q7O0VBRWdCLE1BQVhrSyxXQUFXLENBQUVDLEdBQUYsRUFBT0MsTUFBUCxFQUFlQyxJQUFmLEVBQXFCO0lBQ3BDLE9BQU8sTUFBTSxLQUFLbkssT0FBTCxDQUFhdUosT0FBYixDQUFxQlUsR0FBckIsRUFBMEJDLE1BQTFCLEVBQWtDQyxJQUFsQyxDQUFiO0VBQ0Q7O0VBRWEsTUFBUkMsUUFBUSxDQUFFQyxHQUFGLEVBQU9DLEdBQVAsRUFBWTtJQUN4QixPQUFPLE1BQU0sS0FBS3RLLE9BQUwsQ0FBYXVLLFdBQWIsQ0FBeUJGLEdBQXpCLEVBQThCQyxHQUE5QixDQUFiO0VBQ0Q7O0VBRVksTUFBUHpDLE9BQU8sR0FBSTtJQUNmLElBQUkyQyxHQUFHLEdBQUdDLGVBQUEsQ0FBT0MsU0FBUCxLQUNMLGtFQUFpRSxLQUFLaEwsU0FBVSxZQUQzRSxHQUVMLGlCQUFnQixLQUFLRSxZQUFhLFlBQVcsS0FBS0YsU0FBVSxHQUZqRTtJQUdBLEtBQUtTLEdBQUwsQ0FBU2EsS0FBVCxDQUFnQiwyQ0FBMEN3SixHQUFJLEVBQTlEOztJQUNBLElBQUk7TUFDRixNQUFPRyxpQkFBQSxDQUFFQyxTQUFGLENBQVlDLHNCQUFBLENBQUcxSCxJQUFmLENBQUQsQ0FBdUJxSCxHQUF2QixDQUFOO01BQ0EsS0FBS3JLLEdBQUwsQ0FBU2EsS0FBVCxDQUFlLDJDQUFmO0lBQ0QsQ0FIRCxDQUdFLE9BQU9RLEdBQVAsRUFBWTtNQUNaLEtBQUtyQixHQUFMLENBQVNnQixJQUFULENBQWMsb0NBQWQ7SUFDRDs7SUFFRCxJQUFJLEtBQUtwQyxHQUFULEVBQWM7TUFDWixNQUFNK0wsU0FBUyxHQUFHLEtBQUsvTCxHQUFMLENBQVNOLFVBQVQsQ0FBb0JzTSxXQUFwQixDQUFnQ0MsU0FBaEMsQ0FBMkNDLElBQUQsSUFBVUEsSUFBSSxLQUFLLElBQTdELENBQWxCO01BQ0EsTUFBTUMsSUFBSSxHQUFHSixTQUFTLEdBQUcsQ0FBQyxDQUFiLEdBQWlCLEtBQUsvTCxHQUFMLENBQVNOLFVBQVQsQ0FBb0JzTSxXQUFwQixDQUFnQ0QsU0FBUyxHQUFHLENBQTVDLENBQWpCLEdBQWtFLElBQS9FOztNQUVBLElBQUlJLElBQUosRUFBVTtRQUNSLEtBQUsvSyxHQUFMLENBQVNhLEtBQVQsQ0FBZ0IsaUVBQWdFa0ssSUFBSyxFQUFyRjtNQUNELENBRkQsTUFFTztRQUNMLEtBQUsvSyxHQUFMLENBQVNhLEtBQVQsQ0FBZ0Isd0RBQWhCO01BQ0Q7O01BRUQsSUFBSTtRQUNGLEtBQUssSUFBSW1LLElBQVQsSUFBaUIsTUFBTSxLQUFLcE0sR0FBTCxDQUFTcU0sY0FBVCxFQUF2QixFQUFrRDtVQUVoRCxJQUFJLEVBQUVELElBQUksQ0FBQzlILFFBQUwsQ0FBYyxrQkFBZCxNQUFzQyxDQUFDNkgsSUFBRCxJQUFTQyxJQUFJLENBQUM5SCxRQUFMLENBQWM2SCxJQUFkLENBQS9DLENBQUYsQ0FBSixFQUE0RTtZQUMxRTtVQUNEOztVQUVELElBQUlHLE1BQU0sR0FBR0YsSUFBSSxDQUFDaEQsS0FBTCxDQUFXLEtBQVgsQ0FBYjs7VUFDQSxJQUFJa0QsTUFBTSxDQUFDM0ksTUFBUCxHQUFnQixDQUFwQixFQUF1QjtZQUNyQixNQUFNLEtBQUszRCxHQUFMLENBQVN1TSxpQkFBVCxDQUEyQkQsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVRSxPQUFWLENBQWtCLE9BQWxCLEVBQTJCLEVBQTNCLENBQTNCLENBQU47VUFDRDtRQUNGO01BQ0YsQ0FaRCxDQVlFLE9BQU8vSixHQUFQLEVBQVk7UUFDWixLQUFLckIsR0FBTCxDQUFTZ0IsSUFBVCxDQUFlLDRDQUEyQ0ssR0FBRyxDQUFDQyxPQUFRLGdCQUF0RTtNQUNEO0lBQ0Y7RUFDRjs7RUFFc0IsTUFBakIrSixpQkFBaUIsR0FBSTtJQUd6QixJQUFJO01BQ0YsTUFBTSxLQUFLeEwsT0FBTCxDQUFhdUosT0FBYixDQUFxQixNQUFyQixFQUE2QixLQUE3QixDQUFOO01BQ0EsT0FBTyxJQUFQO0lBQ0QsQ0FIRCxDQUdFLE9BQU81RSxDQUFQLEVBQVU7TUFDVixPQUFPLEtBQVA7SUFDRDtFQUNGOztBQTFvQjRDOzs7QUE2b0IvQzFHLFlBQVksQ0FBQzZLLFdBQWIsR0FBMkIsb0JBQTNCO0FBQ0E3SyxZQUFZLENBQUM4TCxhQUFiLEdBQTZCLGNBQTdCO0FBQ0E5TCxZQUFZLENBQUM4QixhQUFiLEdBQTZCLFNBQTdCO0FBQ0E5QixZQUFZLENBQUNvSixjQUFiLEdBQThCLFVBQTlCO0FBQ0FwSixZQUFZLENBQUNpTCxZQUFiLEdBQTRCLFFBQTVCO0FBQ0FqTCxZQUFZLENBQUNzSyxjQUFiLEdBQThCLFVBQTlCO0FBQ0F0SyxZQUFZLENBQUN1SyxnQkFBYixHQUFnQyxZQUFoQztlQUdldkssWSJ9
