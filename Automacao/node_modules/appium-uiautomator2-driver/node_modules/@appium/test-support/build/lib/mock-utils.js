"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MockStore = void 0;
exports.verifyMocks = verifyMocks;
exports.withMocks = withMocks;

require("source-map-support/register");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _sinon = _interopRequireDefault(require("sinon"));

function withMocks(mockDefs, fn) {
  return () => {
    const mocks = new MockStore();
    beforeEach(function withMocksBeforeEach() {
      mocks.createMocks(mockDefs);
    });
    afterEach(function withMocksAfterEach() {
      mocks.reset();
    });
    fn(mocks);
  };
}

function verifyMocks(mocks) {
  mocks.verify();
}

class MockStore {
  sandbox;
  #mocks;

  constructor(sandbox) {
    this.sandbox = sandbox;
  }

  createMocks(mockDefs) {
    if (this.#mocks) {
      throw new ReferenceError('Cannot create mocks twice; call `reset()` first.');
    }

    this.sandbox = this.sandbox ?? _sinon.default.createSandbox().usingPromise(_bluebird.default);

    for (const [key, value] of Object.entries(mockDefs)) {
      this[key] = this.sandbox.mock(value);
    }

    this.#mocks = mockDefs;
    return this;
  }

  verify() {
    if (!this.sandbox) {
      throw new ReferenceError('Cannot verify mocks before they are created; call `createMocks()` first');
    }

    this.sandbox.verify();
  }

  reset() {
    var _this$sandbox;

    for (const key of Object.keys(this.#mocks ?? {})) {
      delete this[key];
    }

    (_this$sandbox = this.sandbox) === null || _this$sandbox === void 0 ? void 0 : _this$sandbox.restore();
    this.#mocks = undefined;
  }

}

exports.MockStore = MockStore;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ3aXRoTW9ja3MiLCJtb2NrRGVmcyIsImZuIiwibW9ja3MiLCJNb2NrU3RvcmUiLCJiZWZvcmVFYWNoIiwid2l0aE1vY2tzQmVmb3JlRWFjaCIsImNyZWF0ZU1vY2tzIiwiYWZ0ZXJFYWNoIiwid2l0aE1vY2tzQWZ0ZXJFYWNoIiwicmVzZXQiLCJ2ZXJpZnlNb2NrcyIsInZlcmlmeSIsInNhbmRib3giLCJjb25zdHJ1Y3RvciIsIlJlZmVyZW5jZUVycm9yIiwic2lub24iLCJjcmVhdGVTYW5kYm94IiwidXNpbmdQcm9taXNlIiwiQiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIm1vY2siLCJrZXlzIiwicmVzdG9yZSIsInVuZGVmaW5lZCJdLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9tb2NrLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgTW9jaGEgXCJiZWZvcmUgZWFjaFwiIGFuZCBcImFmdGVyIGVhY2hcIiBob29rcyB0b1xuICogYXV0b21hdGljYWxseSBtb2NrIChhbmQgdW4tbW9jaykgdGhlIG1vY2tzIHByb3ZpZGVkIGJ5IGBsaWJzYC5cbiAqXG4gKiBUaGUgdmFsdWVzIG9mIGBsaWJzYCBhcmUgcHJvdmlkZWQgZGlyZWN0bHkgdG8ge0BsaW5rY29kZSBTaW5vblNhbmRib3gubW9ja30uXG4gKlxuICogX1N5bmNocm9ub3VzbHlfIGNhbGxzIGBmbmAgd2l0aCB0aGUge0BsaW5rY29kZSBNb2NrU3RvcmV9IGFmdGVyIGhvb2tzIGhhdmUgYmVlbiBjcmVhdGVkLCBidXQgbm90IGJlZm9yZSB0aGV5IGhhdmUgYmVlbiBydW4uXG4gKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nfHN5bWJvbCxhbnk+fSBtb2NrRGVmc1xuICogQHBhcmFtIHsobW9ja3M6IE1vY2tTdG9yZSkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aE1vY2tzKG1vY2tEZWZzLCBmbikge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tzID0gbmV3IE1vY2tTdG9yZSgpO1xuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gd2l0aE1vY2tzQmVmb3JlRWFjaCgpIHtcbiAgICAgIG1vY2tzLmNyZWF0ZU1vY2tzKG1vY2tEZWZzKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goZnVuY3Rpb24gd2l0aE1vY2tzQWZ0ZXJFYWNoKCkge1xuICAgICAgbW9ja3MucmVzZXQoKTtcbiAgICB9KTtcbiAgICBmbihtb2Nrcyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNhbGxpbmcgYG1vY2tzLnZlcmlmeSgpYC5cbiAqIEBwYXJhbSB7TW9ja1N0b3JlfSBtb2NrcyAtIFJldHVybmVkIGJ5IGNhbGxiYWNrIGZyb20ge0BsaW5rY29kZSB3aXRoTW9ja3N9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlNb2Nrcyhtb2Nrcykge1xuICBtb2Nrcy52ZXJpZnkoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsYW55Pn0gTW9ja3NcbiAqIEBleHRlbmRzIHtNb2Nrc31cbiAqL1xuZXhwb3J0IGNsYXNzIE1vY2tTdG9yZSB7XG4gIC8qKlxuICAgKiBUZW1wb3Jhcnkgc2FuZGJveDsgd2lsbCBiZSBgdW5kZWZpbmVkYCB1bnRpbCBgYmVmb3JlRWFjaGAgaXMgY2FsbGVkXG4gICAqIEB0eXBlIHtTaW5vblNhbmRib3h8dW5kZWZpbmVkfVxuICAgKi9cbiAgc2FuZGJveDtcblxuICAvKipcbiAgICogT3JpZ2luYWwgay92IHBhaXIgcHJvdmlkZWQgdG8gYGNyZWF0ZU1vY2tzYFxuICAgKiBAdHlwZSB7TW9ja3N8dW5kZWZpbmVkfVxuICAgKi9cbiAgI21vY2tzO1xuXG4gIC8qKlxuICAgKiBVc2VzIGEgc2FuZGJveCBpZiBvbmUgaXMgcHJvdmlkZWRcbiAgICogQHBhcmFtIHtTaW5vblNhbmRib3h9IFtzYW5kYm94XVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2FuZGJveCkge1xuICAgIHRoaXMuc2FuZGJveCA9IHNhbmRib3g7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2Nrc30gbW9ja0RlZnNcbiAgICovXG4gIGNyZWF0ZU1vY2tzKG1vY2tEZWZzKSB7XG4gICAgaWYgKHRoaXMuI21vY2tzKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgbW9ja3MgdHdpY2U7IGNhbGwgYHJlc2V0KClgIGZpcnN0LicpO1xuICAgIH1cbiAgICB0aGlzLnNhbmRib3ggPSB0aGlzLnNhbmRib3ggPz8gc2lub24uY3JlYXRlU2FuZGJveCgpLnVzaW5nUHJvbWlzZShCKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtb2NrRGVmcykpIHtcbiAgICAgIHRoaXNba2V5XSA9IHRoaXMuc2FuZGJveC5tb2NrKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy4jbW9ja3MgPSBtb2NrRGVmcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB7QGxpbmtjb2RlIFNpbm9uU2FuZGJveC52ZXJpZnl9IG9uIHRoZSBgc2FuZGJveGAgcHJvcCwgaWYgaXQgZXhpc3RzXG4gICAqL1xuICB2ZXJpZnkoKSB7XG4gICAgaWYgKCF0aGlzLnNhbmRib3gpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB2ZXJpZnkgbW9ja3MgYmVmb3JlIHRoZXkgYXJlIGNyZWF0ZWQ7IGNhbGwgYGNyZWF0ZU1vY2tzKClgIGZpcnN0J1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5zYW5kYm94LnZlcmlmeSgpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy4jbW9ja3MgPz8ge30pKSB7XG4gICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgIH1cbiAgICB0aGlzLnNhbmRib3g/LnJlc3RvcmUoKTtcbiAgICB0aGlzLiNtb2NrcyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3Npbm9uJykuU2lub25TYW5kYm94fSBTaW5vblNhbmRib3hcbiAqL1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBY08sU0FBU0EsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLEVBQTdCLEVBQWlDO0VBQ3RDLE9BQU8sTUFBTTtJQUNYLE1BQU1DLEtBQUssR0FBRyxJQUFJQyxTQUFKLEVBQWQ7SUFDQUMsVUFBVSxDQUFDLFNBQVNDLG1CQUFULEdBQStCO01BQ3hDSCxLQUFLLENBQUNJLFdBQU4sQ0FBa0JOLFFBQWxCO0lBQ0QsQ0FGUyxDQUFWO0lBR0FPLFNBQVMsQ0FBQyxTQUFTQyxrQkFBVCxHQUE4QjtNQUN0Q04sS0FBSyxDQUFDTyxLQUFOO0lBQ0QsQ0FGUSxDQUFUO0lBR0FSLEVBQUUsQ0FBQ0MsS0FBRCxDQUFGO0VBQ0QsQ0FURDtBQVVEOztBQU1NLFNBQVNRLFdBQVQsQ0FBcUJSLEtBQXJCLEVBQTRCO0VBQ2pDQSxLQUFLLENBQUNTLE1BQU47QUFDRDs7QUFNTSxNQUFNUixTQUFOLENBQWdCO0VBS3JCUyxPQUFPO0VBTVAsQ0FBQ1YsS0FBRDs7RUFNQVcsV0FBVyxDQUFDRCxPQUFELEVBQVU7SUFDbkIsS0FBS0EsT0FBTCxHQUFlQSxPQUFmO0VBQ0Q7O0VBS0ROLFdBQVcsQ0FBQ04sUUFBRCxFQUFXO0lBQ3BCLElBQUksS0FBSyxDQUFDRSxLQUFWLEVBQWlCO01BQ2YsTUFBTSxJQUFJWSxjQUFKLENBQW1CLGtEQUFuQixDQUFOO0lBQ0Q7O0lBQ0QsS0FBS0YsT0FBTCxHQUFlLEtBQUtBLE9BQUwsSUFBZ0JHLGNBQUEsQ0FBTUMsYUFBTixHQUFzQkMsWUFBdEIsQ0FBbUNDLGlCQUFuQyxDQUEvQjs7SUFDQSxLQUFLLE1BQU0sQ0FBQ0MsR0FBRCxFQUFNQyxLQUFOLENBQVgsSUFBMkJDLE1BQU0sQ0FBQ0MsT0FBUCxDQUFldEIsUUFBZixDQUEzQixFQUFxRDtNQUNuRCxLQUFLbUIsR0FBTCxJQUFZLEtBQUtQLE9BQUwsQ0FBYVcsSUFBYixDQUFrQkgsS0FBbEIsQ0FBWjtJQUNEOztJQUNELEtBQUssQ0FBQ2xCLEtBQU4sR0FBY0YsUUFBZDtJQUNBLE9BQU8sSUFBUDtFQUNEOztFQUtEVyxNQUFNLEdBQUc7SUFDUCxJQUFJLENBQUMsS0FBS0MsT0FBVixFQUFtQjtNQUNqQixNQUFNLElBQUlFLGNBQUosQ0FDSix5RUFESSxDQUFOO0lBR0Q7O0lBQ0QsS0FBS0YsT0FBTCxDQUFhRCxNQUFiO0VBQ0Q7O0VBRURGLEtBQUssR0FBRztJQUFBOztJQUNOLEtBQUssTUFBTVUsR0FBWCxJQUFrQkUsTUFBTSxDQUFDRyxJQUFQLENBQVksS0FBSyxDQUFDdEIsS0FBTixJQUFlLEVBQTNCLENBQWxCLEVBQWtEO01BQ2hELE9BQU8sS0FBS2lCLEdBQUwsQ0FBUDtJQUNEOztJQUNELHNCQUFLUCxPQUFMLGdFQUFjYSxPQUFkO0lBQ0EsS0FBSyxDQUFDdkIsS0FBTixHQUFjd0IsU0FBZDtFQUNEOztBQXREb0IifQ==